<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wolt onboarding</title>
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #0e1012;
      --surface: #131619;
      --surface2: #181c20;
      --border: #22272e;
      --text: #e0e0e0;
      --muted: #4a5260;
      --muted2: #7a8494;
      --accent: #6b9;
      --accent-dim: #2d4a38;
      --font: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font);
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    /* ── Header ── */
    header {
      flex-shrink: 0;
      padding: 0.75rem 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .wordmark {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--accent);
      letter-spacing: -0.01em;
    }

    .header-hint {
      font-size: 0.7rem;
      color: var(--muted);
      letter-spacing: 0.05em;
    }

    /* ── Message column ── */
    .messages-outer {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      scroll-behavior: smooth;
      /* Chrome/Safari smooth momentum */
      -webkit-overflow-scrolling: touch;
    }

    .messages-inner {
      max-width: 560px;
      margin: 0 auto;
      width: 100%;
      padding: 2rem 1.25rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    /* ── Individual messages ── */
    .msg {
      display: flex;
      flex-direction: column;
      max-width: 88%;
    }

    .msg.wolt {
      align-self: flex-start;
    }

    .msg.human {
      align-self: flex-end;
      align-items: flex-end;
    }

    .msg-bubble {
      padding: 0.75rem 1rem;
      border-radius: 10px;
      font-size: 0.9rem;
      line-height: 1.75;
      word-break: break-word;
    }

    .msg.wolt .msg-bubble {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
    }

    .msg.human .msg-bubble {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.88rem;
      padding-right: 0;
    }

    /* Typing cursor */
    .cursor {
      display: inline-block;
      width: 0.55em;
      height: 1em;
      background: var(--accent);
      vertical-align: text-bottom;
      animation: blink-cursor 0.8s step-end infinite;
      margin-left: 1px;
      border-radius: 1px;
      opacity: 0.85;
    }

    @keyframes blink-cursor {
      0%, 100% { opacity: 0.85; }
      50%       { opacity: 0;    }
    }

    /* Loading dots (while waiting for server) */
    .dots {
      display: flex;
      gap: 5px;
      padding: 0.75rem 1rem;
    }

    .dots span {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: var(--accent);
      animation: dot-pulse 1.2s infinite ease-in-out;
    }
    .dots span:nth-child(2) { animation-delay: 0.2s; }
    .dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes dot-pulse {
      0%, 80%, 100% { transform: scale(0.65); opacity: 0.3; }
      40%           { transform: scale(1.1);  opacity: 1;   }
    }

    /* ── Soul preview (stage 5) ── */
    .soul-preview-wrap {
      width: 100%;
      max-width: 520px;
      align-self: flex-start;
    }

    .soul-preview {
      background: #0a0c0e;
      border: 1px solid var(--accent-dim);
      border-radius: 10px;
      padding: 1rem 1.25rem;
      font-size: 0.78rem;
      line-height: 1.75;
      color: var(--muted2);
      white-space: pre-wrap;
      overflow-y: auto;
      max-height: 280px;
      word-break: break-word;
    }

    /* soul-preview label */
    .soul-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin-bottom: 0.5rem;
    }

    /* ── Stage 5 action buttons ── */
    .soul-actions {
      display: flex;
      gap: 0.625rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }

    .soul-btn {
      padding: 0.45rem 1rem;
      border-radius: 6px;
      font-family: var(--font);
      font-size: 0.78rem;
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid var(--border);
      background: var(--surface2);
      color: var(--muted2);
    }

    .soul-btn.primary {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-dim);
    }

    .soul-btn:hover {
      opacity: 0.75;
    }

    .soul-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Full-width wrapper ensures the border spans the entire bottom edge */
    .input-area-wrap {
      flex-shrink: 0;
      border-top: 1px solid var(--border);
      width: 100%;
    }

    /* ── Input area ── */
    .input-area {
      display: flex;
      align-items: flex-end;
      gap: 0.5rem;
      max-width: 560px;
      margin: 0 auto;
      width: 100%;
      padding: 0.875rem 1.25rem;
      /* Fade in/out */
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .input-area.visible {
      opacity: 1;
      pointer-events: all;
    }

    .ob-input {
      flex: 1;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.65rem 0.875rem;
      font-family: var(--font);
      font-size: 0.875rem;
      color: var(--text);
      outline: none;
      resize: none;
      min-height: 2.4rem;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.5;
      transition: border-color 0.15s;
    }

    .ob-input:focus {
      border-color: var(--accent-dim);
    }

    .ob-input::placeholder {
      color: var(--muted);
    }

    .ob-send {
      flex-shrink: 0;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.65rem 0.875rem;
      font-family: var(--font);
      font-size: 0.8rem;
      color: var(--muted2);
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
      align-self: flex-end;
    }

    .ob-send:hover {
      color: var(--accent);
      border-color: var(--accent-dim);
    }

    /* ── Mobile ── */
    @media (max-width: 480px) {
      header { padding: 0.625rem 1rem; }
      .messages-inner { padding: 1.25rem 1rem 0.75rem; gap: 1rem; }
      .input-area { padding: 0.75rem 1rem; }
      .soul-preview { max-height: 220px; }
      .msg-bubble { font-size: 0.875rem; }
    }
  </style>
</head>
<body>

<header>
  <span class="wordmark" id="wordmark">&#x2B21; ...</span>
  <span class="header-hint">setting up your wolt</span>
</header>

<div class="messages-outer" id="messages-outer">
  <div class="messages-inner" id="messages"></div>
</div>

<div class="input-area-wrap">
  <div class="input-area" id="input-area">
    <textarea
      class="ob-input"
      id="ob-input"
      rows="1"
      placeholder="type your response…"
      autocomplete="off"
      spellcheck="true"
    ></textarea>
    <button class="ob-send" id="ob-send">&#x23CE;</button>
  </div>
</div>

<script>
  // ── State ──
  let stage = 0;
  let history = [];       // [{role: 'wolt'|'human', content: string}]
  let woltName = null;
  let pendingSoul = null;
  let isTyping = false;

  // ── DOM refs ──
  const messagesEl  = document.getElementById('messages');
  const outerEl     = document.getElementById('messages-outer');
  const inputArea   = document.getElementById('input-area');
  const inputEl     = document.getElementById('ob-input');
  const sendBtn     = document.getElementById('ob-send');
  const wordmarkEl  = document.getElementById('wordmark');

  const OPENING = "Hello. I don't have a soul yet — just the space and the potential. Before anything else: what do you want to call this wolt? And what should I call you?";

  // ── Scroll to bottom ──
  function scrollBottom() {
    outerEl.scrollTop = outerEl.scrollHeight;
  }

  // ── Show/hide input ──
  function showInput() {
    inputArea.classList.add('visible');
    // Small defer so the opacity transition is visible
    setTimeout(() => inputEl.focus(), 50);
  }

  function hideInput() {
    inputArea.classList.remove('visible');
  }

  // ── Textarea auto-grow ──
  inputEl.addEventListener('input', () => {
    inputEl.style.height = 'auto';
    inputEl.style.height = Math.min(inputEl.scrollHeight, 120) + 'px';
  });

  // ── Submit on Enter (Shift+Enter = newline) ──
  inputEl.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  });
  sendBtn.addEventListener('click', handleSubmit);

  function handleSubmit() {
    if (isTyping) return;
    const val = inputEl.value.trim();
    if (!val) return;
    inputEl.value = '';
    inputEl.style.height = 'auto';
    sendUserMessage(val);
  }

  // ── Add a message element to the DOM ──
  function addMessage(role) {
    const wrap = document.createElement('div');
    wrap.className = `msg ${role}`;

    const bubble = document.createElement('div');
    bubble.className = 'msg-bubble';
    wrap.appendChild(bubble);

    messagesEl.appendChild(wrap);
    scrollBottom();
    return bubble;
  }

  // ── Loading dots (waiting for server) ──
  function addLoadingBubble() {
    const wrap = document.createElement('div');
    wrap.className = 'msg wolt';
    wrap.id = 'loading-bubble';

    const dotsEl = document.createElement('div');
    dotsEl.className = 'dots';
    dotsEl.innerHTML = '<span></span><span></span><span></span>';
    wrap.appendChild(dotsEl);

    messagesEl.appendChild(wrap);
    scrollBottom();
    return wrap;
  }

  function removeLoadingBubble() {
    const el = document.getElementById('loading-bubble');
    if (el) el.remove();
  }

  // ── Typewriter effect ──
  // Takes a bubble element and a string, types it out at 15ms/char.
  // Returns a promise that resolves when done.
  function typewriter(bubbleEl, text, speed = 15) {
    return new Promise(resolve => {
      let i = 0;
      bubbleEl.textContent = '';

      // Add cursor
      const cursor = document.createElement('span');
      cursor.className = 'cursor';
      bubbleEl.appendChild(cursor);

      function tick() {
        if (i < text.length) {
          // Insert text before cursor
          const textNode = bubbleEl.firstChild;
          if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            textNode.textContent += text[i];
          } else {
            bubbleEl.insertBefore(document.createTextNode(text[i]), cursor);
          }
          i++;
          scrollBottom();
          setTimeout(tick, speed);
        } else {
          // Remove cursor when done
          cursor.remove();
          resolve();
        }
      }

      tick();
    });
  }

  // ── Extract wolt name from response text ──
  function tryExtractName(text) {
    // Patterns: "I'll be [Name]", "call me [Name]", "I'm [Name]",
    // "name is [Name]", "I am [Name]"
    const patterns = [
      /i(?:'ll| will) be ([A-Z][a-z]+(?:[A-Z][a-z]+)?)/i,
      /call me ([A-Z][a-z]+(?:[A-Z][a-z]+)?)/i,
      /i'm ([A-Z][a-z]+(?:[A-Z][a-z]+)?)/i,
      /i am ([A-Z][a-z]+(?:[A-Z][a-z]+)?)/i,
      /name (?:is|will be) ([A-Z][a-z]+(?:[A-Z][a-z]+)?)/i,
      /(?:wolt|space) (?:named?|called?) ([A-Z][a-z]+(?:[A-Z][a-z]+)?)/i,
    ];

    for (const p of patterns) {
      const m = text.match(p);
      if (m && m[1] && m[1].length > 1 && m[1].length < 30) {
        return m[1];
      }
    }
    return null;
  }

  function updateWordmark(name) {
    woltName = name;
    wordmarkEl.textContent = '\u2B21 ' + name;
  }

  // ── Stage 5: show soul preview + action buttons ──
  function showSoulPreview(soulContent) {
    pendingSoul = soulContent;

    const wrap = document.createElement('div');
    wrap.className = 'soul-preview-wrap msg';
    wrap.style.alignSelf = 'flex-start';
    wrap.style.width = '100%';
    wrap.style.maxWidth = '520px';

    const label = document.createElement('div');
    label.className = 'soul-label';
    label.textContent = 'your soul draft';
    wrap.appendChild(label);

    const preview = document.createElement('div');
    preview.className = 'soul-preview';
    preview.textContent = soulContent;
    wrap.appendChild(preview);

    const actions = document.createElement('div');
    actions.className = 'soul-actions';
    actions.id = 'soul-actions';

    const confirmBtn = document.createElement('button');
    confirmBtn.className = 'soul-btn primary';
    confirmBtn.textContent = 'yes, this is right';
    confirmBtn.addEventListener('click', () => {
      confirmBtn.disabled = true;
      adjustBtn.disabled = true;
      confirmSoul(soulContent);
    });

    const adjustBtn = document.createElement('button');
    adjustBtn.className = 'soul-btn';
    adjustBtn.textContent = 'adjust something';
    adjustBtn.addEventListener('click', () => {
      actions.remove();
      inputEl.placeholder = 'what should change?';
      pendingSoul = soulContent;
      stage = 5;
      showInput();
    });

    actions.appendChild(confirmBtn);
    actions.appendChild(adjustBtn);
    wrap.appendChild(actions);

    messagesEl.appendChild(wrap);
    scrollBottom();
  }

  // ── Confirm soul: POST /soul/confirm ──
  async function confirmSoul(soulContent) {
    hideInput();
    try {
      await fetch('/soul/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ soul: soulContent }),
      });
    } catch (err) {
      // Still continue — server might have written it
    }

    // Type out the closing message
    const bubble = addMessage('wolt');
    isTyping = true;
    await typewriter(bubble, "Then let's begin.");
    isTyping = false;

    setTimeout(() => {
      window.location.href = '/';
    }, 1800);
  }

  // ── Show human message in UI ──
  function addHumanMessage(text) {
    const bubble = addMessage('human');
    bubble.textContent = text;
    scrollBottom();
  }

  // ── Fetch from /onboard, collect full response, then typewrite ──
  async function callOnboard(message) {
    hideInput();
    isTyping = true;

    // Show loading dots while waiting
    addLoadingBubble();

    let fullText = '';
    let soulDraft = null;

    try {
      const resp = await fetch('/onboard', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: message || '',
          stage: stage,
          history: history,
          draft: pendingSoul,
        }),
      });

      const reader = resp.body.getReader();
      const dec = new TextDecoder();
      let buf = '';

      // Collect full response (don't show yet)
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buf += dec.decode(value, { stream: true });
        const lines = buf.split('\n');
        buf = lines.pop();

        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          try {
            const ev = JSON.parse(line.slice(6));
            if (ev.type === 'text') {
              fullText += ev.content;
            } else if (ev.type === 'soul_draft') {
              soulDraft = ev.content;
            } else if (ev.type === 'done') {
              stage = ev.nextStage || stage + 1;
            }
          } catch {}
        }
      }
    } catch (err) {
      removeLoadingBubble();
      const bubble = addMessage('wolt');
      bubble.textContent = '— something went wrong: ' + err.message;
      isTyping = false;
      showInput();
      return;
    }

    // Remove loading dots, start typewriter
    removeLoadingBubble();

    if (fullText) {
      const bubble = addMessage('wolt');
      await typewriter(bubble, fullText);

      // Push to history
      history.push({ role: 'wolt', content: fullText });

      // Try to extract wolt name from first real response
      if (!woltName) {
        const name = tryExtractName(fullText);
        if (name) updateWordmark(name);
      }
    }

    // Show soul draft if present
    if (soulDraft) {
      showSoulPreview(soulDraft);
      // Don't show input yet — user picks confirm or adjust
      isTyping = false;
      return;
    }

    isTyping = false;
    showInput();
  }

  // ── User submits a message ──
  async function sendUserMessage(text) {
    // Show user message in UI
    addHumanMessage(text);
    history.push({ role: 'human', content: text });

    // Call server
    await callOnboard(text);
  }

  // ── Stage 0: hardcoded opening, no server call ──
  async function startOnboarding() {
    isTyping = true;
    const bubble = addMessage('wolt');
    await typewriter(bubble, OPENING);
    history.push({ role: 'wolt', content: OPENING });
    stage = 1; // Next human message goes to stage 1
    isTyping = false;
    showInput();
  }

  // ── Boot ──
  startOnboarding();
</script>

</body>
</html>
