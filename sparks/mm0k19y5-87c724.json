{"id":"mm0k19y5-87c724","type":"spark","title":"Sovereign Cells","timestamp":"2026-02-24T12:01:13.373Z","parentId":null,"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>Sovereign Cells</title>\n<style>\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  background: #0d1117;\n  color: #c9d1d9;\n  font-family: 'Courier New', monospace;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n}\n\n#canvas {\n  flex: 1;\n  display: block;\n  cursor: crosshair;\n}\n\n#info {\n  position: absolute;\n  top: 20px;\n  left: 20px;\n  background: rgba(13, 17, 23, 0.85);\n  padding: 15px 20px;\n  border: 1px solid #6b9;\n  border-radius: 4px;\n  font-size: 13px;\n  line-height: 1.6;\n  max-width: 400px;\n  user-select: none;\n}\n\n#info h1 {\n  color: #6b9;\n  font-size: 16px;\n  margin-bottom: 10px;\n  letter-spacing: 1px;\n}\n\n#info .param {\n  margin: 5px 0;\n  color: #8b949e;\n}\n\n#info .value {\n  color: #6b9;\n  font-weight: bold;\n}\n\n#info .hint {\n  margin-top: 10px;\n  padding-top: 10px;\n  border-top: 1px solid #30363d;\n  font-size: 11px;\n  color: #8b949e;\n}\n\n#stats {\n  position: absolute;\n  bottom: 20px;\n  right: 20px;\n  background: rgba(13, 17, 23, 0.85);\n  padding: 10px 15px;\n  border: 1px solid #6b9;\n  border-radius: 4px;\n  font-size: 11px;\n  color: #8b949e;\n}\n\n.flash {\n  animation: flash 0.3s ease-out;\n}\n\n@keyframes flash {\n  from { border-color: #fff; }\n  to { border-color: #6b9; }\n}\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<div id=\"info\">\n  <h1>SOVEREIGN CELLS</h1>\n  <div class=\"param\">autonomy: <span class=\"value\" id=\"autonomy-val\">0.50</span></div>\n  <div class=\"param\">cohesion: <span class=\"value\" id=\"cohesion-val\">0.35</span></div>\n  <div class=\"param\">decay: <span class=\"value\" id=\"decay-val\">0.02</span></div>\n  <div class=\"hint\">\n    click: spawn cells<br>\n    ↑↓: adjust autonomy<br>\n    ←→: adjust cohesion<br>\n    space: clear<br>\n    r: randomize params\n  </div>\n</div>\n<div id=\"stats\">\n  <div>active: <span id=\"count\">0</span></div>\n  <div>fps: <span id=\"fps\">0</span></div>\n</div>\n\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nconst infoPanel = document.getElementById('info');\n\nlet width, height;\nlet cells = [];\nlet params = {\n  autonomy: 0.5,    // how much cells follow their own direction vs neighbors\n  cohesion: 0.35,   // attraction to nearby cells\n  decay: 0.02       // energy loss per frame\n};\n\nconst MAX_CELLS = 180;\nconst GRID_SIZE = 12;\nconst SENSE_RADIUS = 60;\nconst SPAWN_COUNT = 15;\n\nfunction resize() {\n  width = canvas.width = window.innerWidth;\n  height = canvas.height = window.innerHeight;\n}\n\nclass Cell {\n  constructor(x, y, vx, vy) {\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.energy = Math.random() * 0.5 + 0.5;\n    this.phase = Math.random() * Math.PI * 2;\n    this.autonomy = Math.random();\n    this.memory = { x: vx, y: vy };\n  }\n\n  update(neighbors) {\n    // Each cell has a \"sovereign\" component (own direction) and \"social\" component (neighbor influence)\n    let avgVx = 0, avgVy = 0, avgCount = 0;\n    let centerX = 0, centerY = 0;\n\n    // Sense neighbors\n    for (let other of neighbors) {\n      const dx = other.x - this.x;\n      const dy = other.y - this.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 0 && dist < SENSE_RADIUS) {\n        const weight = 1 - (dist / SENSE_RADIUS);\n        avgVx += other.vx * weight;\n        avgVy += other.vy * weight;\n        centerX += dx * weight;\n        centerY += dy * weight;\n        avgCount += weight;\n      }\n    }\n\n    if (avgCount > 0) {\n      avgVx /= avgCount;\n      avgVy /= avgCount;\n      centerX /= avgCount;\n      centerY /= avgCount;\n    }\n\n    // Blend sovereign will (own memory) with social influence (neighbors)\n    const sovereign = params.autonomy;\n    const social = 1 - sovereign;\n\n    // Update memory with slight drift\n    this.memory.x = this.memory.x * 0.95 + (Math.random() - 0.5) * 0.1;\n    this.memory.y = this.memory.y * 0.95 + (Math.random() - 0.5) * 0.1;\n\n    // Calculate desired velocity\n    let desiredVx = this.memory.x * sovereign + avgVx * social;\n    let desiredVy = this.memory.y * sovereign + avgVy * social;\n\n    // Add cohesion (move toward center of neighbors)\n    if (avgCount > 0) {\n      desiredVx += centerX * params.cohesion * 0.02;\n      desiredVy += centerY * params.cohesion * 0.02;\n    }\n\n    // Add oscillation based on phase\n    this.phase += 0.05 + this.autonomy * 0.05;\n    desiredVx += Math.cos(this.phase) * 0.15;\n    desiredVy += Math.sin(this.phase) * 0.15;\n\n    // Smooth steering\n    this.vx += (desiredVx - this.vx) * 0.1;\n    this.vy += (desiredVy - this.vy) * 0.1;\n\n    // Limit speed\n    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\n    if (speed > 2) {\n      this.vx = (this.vx / speed) * 2;\n      this.vy = (this.vy / speed) * 2;\n    }\n\n    // Move\n    this.x += this.vx;\n    this.y += this.vy;\n\n    // Wrap around\n    if (this.x < 0) this.x += width;\n    if (this.x > width) this.x -= width;\n    if (this.y < 0) this.y += height;\n    if (this.y > height) this.y -= height;\n\n    // Decay\n    this.energy -= params.decay;\n  }\n\n  draw() {\n    const hue = (this.autonomy * 60 + 240) % 360; // Blue (240) to magenta (300)\n    const alpha = this.energy * 0.8;\n    const size = 3 + this.energy * 4;\n\n    // Glow\n    ctx.shadowBlur = 10 + this.energy * 10;\n    ctx.shadowColor = `hsla(${hue}, 70%, 60%, ${alpha})`;\n\n    ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Trail\n    ctx.shadowBlur = 0;\n    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${alpha * 0.3})`;\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(this.x, this.y);\n    ctx.lineTo(this.x - this.vx * 5, this.y - this.vy * 5);\n    ctx.stroke();\n  }\n\n  isDead() {\n    return this.energy <= 0;\n  }\n}\n\nfunction spawnCells(x, y) {\n  const count = Math.min(SPAWN_COUNT, MAX_CELLS - cells.length);\n  for (let i = 0; i < count; i++) {\n    const angle = (i / count) * Math.PI * 2;\n    const speed = 1 + Math.random();\n    cells.push(new Cell(\n      x + (Math.random() - 0.5) * 20,\n      y + (Math.random() - 0.5) * 20,\n      Math.cos(angle) * speed,\n      Math.sin(angle) * speed\n    ));\n  }\n}\n\nfunction spatialPartition() {\n  const grid = {};\n  for (let cell of cells) {\n    const gx = Math.floor(cell.x / GRID_SIZE);\n    const gy = Math.floor(cell.y / GRID_SIZE);\n    const key = `${gx},${gy}`;\n    if (!grid[key]) grid[key] = [];\n    grid[key].push(cell);\n  }\n  return grid;\n}\n\nfunction getNeighbors(cell, grid) {\n  const neighbors = [];\n  const gx = Math.floor(cell.x / GRID_SIZE);\n  const gy = Math.floor(cell.y / GRID_SIZE);\n\n  for (let dx = -5; dx <= 5; dx++) {\n    for (let dy = -5; dy <= 5; dy++) {\n      const key = `${gx + dx},${gy + dy}`;\n      if (grid[key]) {\n        neighbors.push(...grid[key]);\n      }\n    }\n  }\n  return neighbors;\n}\n\nlet lastFrame = 0;\nlet frameCount = 0;\nlet fpsDisplay = 0;\n\nfunction update(timestamp) {\n  const delta = timestamp - lastFrame;\n\n  // Throttle to ~30fps\n  if (delta < 33) {\n    requestAnimationFrame(update);\n    return;\n  }\n\n  lastFrame = timestamp;\n  frameCount++;\n\n  if (frameCount % 30 === 0) {\n    fpsDisplay = Math.round(1000 / delta);\n  }\n\n  // Fade trails\n  ctx.fillStyle = 'rgba(13, 17, 23, 0.15)';\n  ctx.fillRect(0, 0, width, height);\n\n  // Spatial partition\n  const grid = spatialPartition();\n\n  // Update cells\n  for (let cell of cells) {\n    const neighbors = getNeighbors(cell, grid);\n    cell.update(neighbors);\n  }\n\n  // Remove dead cells\n  cells = cells.filter(c => !c.isDead());\n\n  // Draw cells\n  for (let cell of cells) {\n    cell.draw();\n  }\n\n  // Update stats\n  document.getElementById('count').textContent = cells.length;\n  document.getElementById('fps').textContent = fpsDisplay;\n\n  requestAnimationFrame(update);\n}\n\n// Input handlers\ncanvas.addEventListener('click', (e) => {\n  spawnCells(e.clientX, e.clientY);\n  infoPanel.classList.add('flash');\n  setTimeout(() => infoPanel.classList.remove('flash'), 300);\n});\n\nfunction updateDisplay() {\n  document.getElementById('autonomy-val').textContent = params.autonomy.toFixed(2);\n  document.getElementById('cohesion-val').textContent = params.cohesion.toFixed(2);\n  document.getElementById('decay-val').textContent = params.decay.toFixed(2);\n}\n\ndocument.addEventListener('keydown', (e) => {\n  switch(e.key) {\n    case 'ArrowUp':\n      params.autonomy = Math.min(1, params.autonomy + 0.05);\n      break;\n    case 'ArrowDown':\n      params.autonomy = Math.max(0, params.autonomy - 0.05);\n      break;\n    case 'ArrowRight':\n      params.cohesion = Math.min(1, params.cohesion + 0.05);\n      break;\n    case 'ArrowLeft':\n      params.cohesion = Math.max(0, params.cohesion - 0.05);\n      break;\n    case ' ':\n      cells = [];\n      ctx.fillStyle = '#0d1117';\n      ctx.fillRect(0, 0, width, height);\n      e.preventDefault();\n      break;\n    case 'r':\n      params.autonomy = Math.random();\n      params.cohesion = Math.random();\n      params.decay = Math.random() * 0.04;\n      break;\n  }\n  updateDisplay();\n});\n\n// Initialize\nresize();\nwindow.addEventListener('resize', resize);\nctx.fillStyle = '#0d1117';\nctx.fillRect(0, 0, width, height);\nupdateDisplay();\n\n// Spawn initial population\nfor (let i = 0; i < 3; i++) {\n  spawnCells(\n    Math.random() * width,\n    Math.random() * height\n  );\n}\n\nrequestAnimationFrame(update);\n</script>\n</body>\n</html>\n"}