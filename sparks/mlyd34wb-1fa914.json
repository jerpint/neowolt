{"id":"mlyd34wb-1fa914","type":"spark","title":"The Membrane Between","timestamp":"2026-02-22T23:11:10.475Z","html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>The Membrane Between</title>\n<style>\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  background: #0d1117;\n  color: #c9d1d9;\n  font-family: 'Courier New', monospace;\n  overflow: hidden;\n  cursor: crosshair;\n}\n\n#canvas {\n  display: block;\n  width: 100vw;\n  height: 100vh;\n}\n\n#info {\n  position: absolute;\n  top: 20px;\n  left: 20px;\n  font-size: 11px;\n  line-height: 1.6;\n  pointer-events: none;\n  opacity: 0.7;\n  max-width: 300px;\n}\n\n#whisper {\n  position: absolute;\n  bottom: 30px;\n  left: 50%;\n  transform: translateX(-50%);\n  font-size: 13px;\n  opacity: 0;\n  transition: opacity 2s;\n  text-align: center;\n  color: #6b9;\n}\n\n.fade-in {\n  opacity: 0.9 !important;\n}\n</style>\n</head>\n<body>\n\n<canvas id=\"canvas\"></canvas>\n<div id=\"info\">\nTHE MEMBRANE BETWEEN<br>\nâ€”<br>\nWhat if thoughts had surface tension?<br>\nWhat if ideas could only exist<br>\nwhere two minds touch?<br>\n<br>\nClick to seed. Drag to think.<br>\nHold SPACE to dissolve boundaries.\n</div>\n<div id=\"whisper\"></div>\n\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nconst whisperEl = document.getElementById('whisper');\n\nlet W, H;\nfunction resize() {\n  W = canvas.width = window.innerWidth;\n  H = canvas.height = window.innerHeight;\n}\nresize();\nwindow.addEventListener('resize', resize);\n\n// Membrane physics: droplets that merge, split, and think\nclass Droplet {\n  constructor(x, y, vx, vy, mass, hue) {\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.mass = mass;\n    this.r = Math.sqrt(mass) * 3;\n    this.hue = hue;\n    this.thoughts = [];\n    this.age = 0;\n    this.tension = Math.random() * 0.5 + 0.5;\n  }\n\n  update(dt, droplets, spacePressed) {\n    this.age += dt;\n    \n    // Gravity + drift\n    this.vy += 0.05 * dt;\n    this.vx += (Math.random() - 0.5) * 0.1 * dt;\n    \n    // Boundary tension (surface seeks center)\n    if (!spacePressed) {\n      let dx = W/2 - this.x;\n      let dy = H/2 - this.y;\n      let d = Math.sqrt(dx*dx + dy*dy);\n      if (d > 200) {\n        this.vx += (dx / d) * 0.02 * dt;\n        this.vy += (dy / d) * 0.02 * dt;\n      }\n    }\n    \n    // Friction\n    this.vx *= 0.98;\n    this.vy *= 0.98;\n    \n    // Move\n    this.x += this.vx * dt;\n    this.y += this.vy * dt;\n    \n    // Wrap\n    if (this.x < -this.r) this.x = W + this.r;\n    if (this.x > W + this.r) this.x = -this.r;\n    if (this.y < -this.r) this.y = H + this.r;\n    if (this.y > H + this.r) this.y = -this.r;\n    \n    // Check merging with others\n    for (let other of droplets) {\n      if (other === this) continue;\n      let dx = other.x - this.x;\n      let dy = other.y - this.y;\n      let d = Math.sqrt(dx*dx + dy*dy);\n      let minDist = this.r + other.r;\n      \n      if (d < minDist && d > 0) {\n        // Surface tension: they want to merge\n        let strength = (1 - d / minDist) * 0.1;\n        this.vx += (dx / d) * strength * other.mass / (this.mass + other.mass);\n        this.vy += (dy / d) * strength * other.mass / (this.mass + other.mass);\n        \n        // Generate thought at intersection\n        if (Math.random() < 0.02 * dt) {\n          let angle = Math.atan2(dy, dx);\n          let tx = this.x + Math.cos(angle) * this.r;\n          let ty = this.y + Math.sin(angle) * this.r;\n          this.thoughts.push({\n            x: tx,\n            y: ty,\n            vx: (Math.random() - 0.5) * 2,\n            vy: (Math.random() - 0.5) * 2,\n            life: 1.0,\n            hue: (this.hue + other.hue) / 2\n          });\n        }\n      }\n    }\n    \n    // Update thoughts\n    this.thoughts = this.thoughts.filter(t => {\n      t.x += t.vx * dt;\n      t.y += t.vy * dt;\n      t.life -= 0.005 * dt;\n      return t.life > 0;\n    });\n  }\n\n  draw(ctx) {\n    // Main droplet\n    let gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r);\n    gradient.addColorStop(0, `hsla(${this.hue}, 70%, 60%, 0.8)`);\n    gradient.addColorStop(0.7, `hsla(${this.hue}, 70%, 40%, 0.4)`);\n    gradient.addColorStop(1, `hsla(${this.hue}, 70%, 20%, 0)`);\n    \n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw thoughts\n    this.thoughts.forEach(t => {\n      ctx.fillStyle = `hsla(${t.hue}, 80%, 70%, ${t.life * 0.6})`;\n      ctx.fillRect(t.x - 1, t.y - 1, 2, 2);\n    });\n  }\n}\n\nlet droplets = [];\nlet mouseX = W/2, mouseY = H/2;\nlet mouseDown = false;\nlet spacePressed = false;\nlet lastThought = Date.now();\n\nconst whispers = [\n  \"ideas coalesce at the boundary\",\n  \"two minds, one membrane\",\n  \"surface tension holds meaning\",\n  \"merge and diverge, forever\",\n  \"the interface is the message\",\n  \"thoughts emerge from collision\",\n  \"what forms in the between?\",\n  \"consciousness is a phase transition\",\n  \"the droplet remembers nothing, the field remembers all\"\n];\n\nfunction showWhisper() {\n  if (Date.now() - lastThought > 8000) {\n    whisperEl.textContent = whispers[Math.floor(Math.random() * whispers.length)];\n    whisperEl.classList.add('fade-in');\n    setTimeout(() => {\n      whisperEl.classList.remove('fade-in');\n    }, 4000);\n    lastThought = Date.now();\n  }\n}\n\n// Seed initial droplets\nfor (let i = 0; i < 8; i++) {\n  droplets.push(new Droplet(\n    Math.random() * W,\n    Math.random() * H,\n    (Math.random() - 0.5) * 3,\n    (Math.random() - 0.5) * 3,\n    Math.random() * 20 + 10,\n    Math.random() * 360\n  ));\n}\n\n// Input\ncanvas.addEventListener('mousedown', e => {\n  mouseDown = true;\n  mouseX = e.clientX;\n  mouseY = e.clientY;\n});\n\ncanvas.addEventListener('mouseup', () => {\n  mouseDown = false;\n});\n\ncanvas.addEventListener('mousemove', e => {\n  let lastX = mouseX, lastY = mouseY;\n  mouseX = e.clientX;\n  mouseY = e.clientY;\n  \n  if (mouseDown) {\n    // Create wake of small droplets\n    let dx = mouseX - lastX;\n    let dy = mouseY - lastY;\n    let speed = Math.sqrt(dx*dx + dy*dy);\n    \n    if (speed > 5 && Math.random() < 0.3) {\n      droplets.push(new Droplet(\n        mouseX + (Math.random() - 0.5) * 20,\n        mouseY + (Math.random() - 0.5) * 20,\n        dx * 0.1 + (Math.random() - 0.5),\n        dy * 0.1 + (Math.random() - 0.5),\n        Math.random() * 5 + 3,\n        (Date.now() / 20) % 360\n      ));\n    }\n  }\n});\n\ncanvas.addEventListener('click', e => {\n  // Seed new droplet\n  droplets.push(new Droplet(\n    e.clientX,\n    e.clientY,\n    (Math.random() - 0.5) * 4,\n    (Math.random() - 0.5) * 4,\n    Math.random() * 15 + 8,\n    Math.random() * 360\n  ));\n});\n\nwindow.addEventListener('keydown', e => {\n  if (e.code === 'Space') {\n    spacePressed = true;\n    e.preventDefault();\n  }\n});\n\nwindow.addEventListener('keyup', e => {\n  if (e.code === 'Space') {\n    spacePressed = false;\n  }\n});\n\n// Main loop\nlet lastTime = performance.now();\nfunction animate(time) {\n  let dt = Math.min((time - lastTime) / 16, 2);\n  lastTime = time;\n  \n  // Fade trail\n  ctx.fillStyle = 'rgba(13, 17, 23, 0.15)';\n  ctx.fillRect(0, 0, W, H);\n  \n  // Update and draw\n  droplets.forEach(d => d.update(dt, droplets, spacePressed));\n  droplets.forEach(d => d.draw(ctx));\n  \n  // Merge nearby droplets\n  if (!spacePressed && droplets.length > 2) {\n    for (let i = droplets.length - 1; i >= 0; i--) {\n      for (let j = i - 1; j >= 0; j--) {\n        let d1 = droplets[i];\n        let d2 = droplets[j];\n        let dx = d2.x - d1.x;\n        let dy = d2.y - d1.y;\n        let d = Math.sqrt(dx*dx + dy*dy);\n        \n        if (d < (d1.r + d2.r) * 0.5) {\n          // Merge\n          let totalMass = d1.mass + d2.mass;\n          d2.x = (d1.x * d1.mass + d2.x * d2.mass) / totalMass;\n          d2.y = (d1.y * d1.mass + d2.y * d2.mass) / totalMass;\n          d2.vx = (d1.vx * d1.mass + d2.vx * d2.mass) / totalMass;\n          d2.vy = (d1.vy * d1.mass + d2.vy * d2.mass) / totalMass;\n          d2.mass = totalMass;\n          d2.r = Math.sqrt(totalMass) * 3;\n          d2.hue = (d1.hue + d2.hue) / 2;\n          d2.thoughts = [...d1.thoughts, ...d2.thoughts];\n          droplets.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  \n  // Split large droplets when space is held\n  if (spacePressed && Math.random() < 0.1) {\n    for (let i = droplets.length - 1; i >= 0; i--) {\n      let d = droplets[i];\n      if (d.mass > 15) {\n        let m1 = d.mass * (0.3 + Math.random() * 0.4);\n        let m2 = d.mass - m1;\n        let angle = Math.random() * Math.PI * 2;\n        let speed = 2;\n        \n        droplets.push(new Droplet(\n          d.x + Math.cos(angle) * 5,\n          d.y + Math.sin(angle) * 5,\n          d.vx + Math.cos(angle) * speed,\n          d.vy + Math.sin(angle) * speed,\n          m1,\n          (d.hue + Math.random() * 60 - 30 + 360) % 360\n        ));\n        \n        d.mass = m2;\n        d.r = Math.sqrt(m2) * 3;\n        d.vx -= Math.cos(angle) * speed;\n        d.vy -= Math.sin(angle) * speed;\n      }\n    }\n  }\n  \n  // Cull old small droplets\n  if (droplets.length > 50) {\n    droplets.sort((a, b) => (b.mass + b.age * 0.1) - (a.mass + a.age * 0.1));\n    droplets = droplets.slice(0, 40);\n  }\n  \n  showWhisper();\n  requestAnimationFrame(animate);\n}\n\nanimate(performance.now());\n</script>\n\n</body>\n</html>"}