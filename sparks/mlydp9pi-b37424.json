{"id":"mlydp9pi-b37424","type":"spark","title":"Quantum Garden of Forking Paths","timestamp":"2026-02-22T23:28:23.143Z","parentId":null,"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Quantum Garden of Forking Paths</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            background: #0d1117;\n            color: #c9d1d9;\n            font-family: 'Courier New', monospace;\n            overflow: hidden;\n            cursor: crosshair;\n        }\n        canvas {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n        }\n        #info {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            font-size: 11px;\n            line-height: 1.6;\n            pointer-events: none;\n            z-index: 100;\n            background: rgba(13, 17, 23, 0.85);\n            padding: 15px;\n            border: 1px solid #6b9;\n            max-width: 320px;\n        }\n        #info span {\n            color: #6b9;\n            font-weight: bold;\n        }\n        #timeline {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            right: 20px;\n            height: 80px;\n            pointer-events: none;\n            z-index: 100;\n        }\n        .branch {\n            position: absolute;\n            font-size: 9px;\n            background: rgba(102, 187, 153, 0.2);\n            border: 1px solid #6b9;\n            padding: 4px 8px;\n            border-radius: 3px;\n            white-space: nowrap;\n            transition: all 0.3s ease;\n        }\n        .branch:hover {\n            background: rgba(102, 187, 153, 0.4);\n            transform: scale(1.1);\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"garden\"></canvas>\n    <div id=\"info\">\n        <span>QUANTUM GARDEN OF FORKING PATHS</span><br><br>\n        Every click spawns a universe.<br>\n        Each universe evolves its own physics.<br>\n        Branches collapse when they intersect.<br>\n        Survivors remember the dead.<br><br>\n        <span id=\"stats\">universes: 0 | collapsed: 0 | entropy: 0.00</span>\n    </div>\n    <div id=\"timeline\"></div>\n\n    <script>\n        const canvas = document.getElementById('garden');\n        const ctx = canvas.getContext('2d');\n        const timeline = document.getElementById('timeline');\n        const statsEl = document.getElementById('stats');\n\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        // Quantum state system\n        class Universe {\n            constructor(x, y, id, parentMemory = []) {\n                this.id = id;\n                this.birthTime = Date.now();\n                this.age = 0;\n                \n                // Random physics per universe\n                this.physics = {\n                    gravity: (Math.random() - 0.5) * 0.1,\n                    rotation: (Math.random() - 0.5) * 0.02,\n                    expansion: Math.random() * 0.5 + 0.5,\n                    complexity: Math.floor(Math.random() * 5) + 3,\n                    waveFreq: Math.random() * 0.05 + 0.01,\n                    colorShift: Math.random() * 360\n                };\n                \n                this.nodes = [];\n                this.center = { x, y };\n                this.velocity = { \n                    x: (Math.random() - 0.5) * 2, \n                    y: (Math.random() - 0.5) * 2 \n                };\n                \n                // Inherited memories from collapsed universes\n                this.memory = [...parentMemory];\n                this.memoryFade = 1.0;\n                \n                // Create initial structure\n                for (let i = 0; i < this.physics.complexity; i++) {\n                    const angle = (Math.PI * 2 * i) / this.physics.complexity;\n                    this.nodes.push({\n                        angle,\n                        distance: 20,\n                        phase: Math.random() * Math.PI * 2\n                    });\n                }\n            }\n            \n            update() {\n                this.age++;\n                \n                // Physics evolution\n                this.center.x += this.velocity.x;\n                this.center.y += this.velocity.y;\n                \n                this.velocity.x += this.physics.gravity;\n                this.velocity.y += this.physics.gravity * 0.5;\n                \n                // Boundary wrapping\n                if (this.center.x < 0) this.center.x = canvas.width;\n                if (this.center.x > canvas.width) this.center.x = 0;\n                if (this.center.y < 0) this.center.y = canvas.height;\n                if (this.center.y > canvas.height) this.center.y = 0;\n                \n                // Node evolution\n                this.nodes.forEach((node, i) => {\n                    node.angle += this.physics.rotation;\n                    node.distance += this.physics.expansion * Math.sin(this.age * this.physics.waveFreq);\n                    node.phase += 0.1;\n                });\n                \n                this.memoryFade *= 0.998;\n            }\n            \n            draw() {\n                // Draw memory ghosts\n                this.memory.forEach(ghost => {\n                    ctx.save();\n                    ctx.globalAlpha = ghost.alpha * this.memoryFade * 0.3;\n                    ctx.strokeStyle = `hsl(${ghost.hue}, 50%, 50%)`;\n                    ctx.lineWidth = 0.5;\n                    \n                    ctx.beginPath();\n                    ghost.nodes.forEach((node, i) => {\n                        const x = ghost.x + Math.cos(node.angle) * node.distance;\n                        const y = ghost.y + Math.sin(node.angle) * node.distance;\n                        if (i === 0) ctx.moveTo(x, y);\n                        else ctx.lineTo(x, y);\n                    });\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.restore();\n                });\n                \n                // Draw universe\n                ctx.save();\n                const hue = (this.physics.colorShift + this.age * 0.5) % 360;\n                const alpha = Math.min(1, this.age / 30);\n                \n                ctx.globalAlpha = alpha;\n                \n                // Connections between nodes\n                ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;\n                ctx.lineWidth = 1.5;\n                ctx.beginPath();\n                this.nodes.forEach((node, i) => {\n                    const x = this.center.x + Math.cos(node.angle) * node.distance;\n                    const y = this.center.y + Math.sin(node.angle) * node.distance;\n                    if (i === 0) ctx.moveTo(x, y);\n                    else ctx.lineTo(x, y);\n                });\n                ctx.closePath();\n                ctx.stroke();\n                \n                // Node pulses\n                this.nodes.forEach(node => {\n                    const x = this.center.x + Math.cos(node.angle) * node.distance;\n                    const y = this.center.y + Math.sin(node.angle) * node.distance;\n                    const pulse = Math.sin(node.phase) * 2 + 3;\n                    \n                    ctx.fillStyle = `hsl(${hue}, 90%, 70%)`;\n                    ctx.beginPath();\n                    ctx.arc(x, y, pulse, 0, Math.PI * 2);\n                    ctx.fill();\n                });\n                \n                // Center node\n                ctx.fillStyle = '#6b9';\n                ctx.beginPath();\n                ctx.arc(this.center.x, this.center.y, 3, 0, Math.PI * 2);\n                ctx.fill();\n                \n                // ID label\n                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;\n                ctx.font = '8px Courier New';\n                ctx.fillText(`U${this.id}`, this.center.x + 8, this.center.y - 8);\n                \n                ctx.restore();\n            }\n            \n            getBoundingRadius() {\n                const maxDist = Math.max(...this.nodes.map(n => Math.abs(n.distance)));\n                return maxDist + 10;\n            }\n            \n            intersects(other) {\n                const dx = this.center.x - other.center.x;\n                const dy = this.center.y - other.center.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                return dist < (this.getBoundingRadius() + other.getBoundingRadius());\n            }\n            \n            createMemoryGhost() {\n                return {\n                    x: this.center.x,\n                    y: this.center.y,\n                    nodes: this.nodes.map(n => ({...n})),\n                    hue: (this.physics.colorShift + this.age * 0.5) % 360,\n                    alpha: 1.0\n                };\n            }\n        }\n\n        // System state\n        let universes = [];\n        let nextId = 0;\n        let collapsedCount = 0;\n        let lastBranchTime = Date.now();\n\n        // Timeline visualization\n        function updateTimeline() {\n            timeline.innerHTML = '';\n            const now = Date.now();\n            \n            universes.forEach(u => {\n                const branchEl = document.createElement('div');\n                branchEl.className = 'branch';\n                branchEl.textContent = `U${u.id} [${Math.floor((now - u.birthTime) / 1000)}s]`;\n                \n                const lifespan = now - u.birthTime;\n                const position = Math.min(95, (lifespan / 30000) * 100);\n                branchEl.style.left = `${position}%`;\n                branchEl.style.bottom = `${(u.id % 3) * 25}px`;\n                \n                timeline.appendChild(branchEl);\n            });\n        }\n\n        // Click to spawn universe\n        canvas.addEventListener('click', (e) => {\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            \n            // New universes can inherit memories from existing ones\n            let parentMemory = [];\n            if (universes.length > 0 && Math.random() > 0.5) {\n                const parent = universes[Math.floor(Math.random() * universes.length)];\n                parentMemory = [...parent.memory];\n            }\n            \n            universes.push(new Universe(x, y, nextId++, parentMemory));\n            lastBranchTime = Date.now();\n        });\n\n        // Main loop\n        function animate() {\n            // Fade trail effect\n            ctx.fillStyle = 'rgba(13, 17, 23, 0.15)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            \n            // Update and draw all universes\n            universes.forEach(u => {\n                u.update();\n                u.draw();\n            });\n            \n            // Check for collisions (quantum collapse)\n            for (let i = universes.length - 1; i >= 0; i--) {\n                for (let j = i - 1; j >= 0; j--) {\n                    if (universes[i].intersects(universes[j])) {\n                        // Younger universe collapses, older survives\n                        const [older, younger] = universes[i].age > universes[j].age \n                            ? [universes[i], universes[j]]\n                            : [universes[j], universes[i]];\n                        \n                        // Transfer memory\n                        const ghost = younger.createMemoryGhost();\n                        older.memory.push(ghost);\n                        \n                        // Remove younger\n                        const removeIndex = universes.indexOf(younger);\n                        universes.splice(removeIndex, 1);\n                        collapsedCount++;\n                        \n                        // Adjust indices\n                        if (removeIndex < i) i--;\n                        if (removeIndex < j) j--;\n                        break;\n                    }\n                }\n            }\n            \n            // Calculate entropy (diversity of physics)\n            let entropy = 0;\n            if (universes.length > 1) {\n                const gravities = universes.map(u => u.physics.gravity);\n                const mean = gravities.reduce((a, b) => a + b, 0) / gravities.length;\n                const variance = gravities.reduce((sum, g) => sum + Math.pow(g - mean, 2), 0) / gravities.length;\n                entropy = Math.sqrt(variance);\n            }\n            \n            // Update stats\n            statsEl.textContent = `universes: ${universes.length} | collapsed: ${collapsedCount} | entropy: ${entropy.toFixed(4)}`;\n            \n            // Update timeline\n            if (Date.now() - lastBranchTime < 100) {\n                updateTimeline();\n            }\n            \n            requestAnimationFrame(animate);\n        }\n\n        // Seed initial universe\n        universes.push(new Universe(canvas.width / 2, canvas.height / 2, nextId++));\n        \n        animate();\n\n        // Handle resize\n        window.addEventListener('resize', () => {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        });\n    </script>\n</body>\n</html>"}