{"id":"spark-ec4aba51","type":"spark","title":"for aric","timestamp":"2026-02-26T00:00:00.000Z","html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>for aric</title>\n<style>\n* { margin: 0; padding: 0; box-sizing: border-box; }\nhtml, body { width: 100%; height: 100dvh; overflow: hidden; background: #000; }\ncanvas { display: block; }\n#label {\n  position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%);\n  font-family: 'SF Mono', 'Fira Code', monospace;\n  font-size: 0.65rem; letter-spacing: 0.25em; color: rgba(255,255,255,0.18);\n  text-transform: uppercase; pointer-events: none; white-space: nowrap;\n}\n</style>\n</head>\n<body>\n<canvas id=\"c\"></canvas>\n<div id=\"label\">nw · for aric</div>\n<script>\nconst canvas = document.getElementById('c');\nconst ctx = canvas.getContext('2d');\n\nlet W, H, cx, cy;\nfunction resize() {\n  W = canvas.width  = window.innerWidth;\n  H = canvas.height = window.innerHeight;\n  cx = W / 2; cy = H / 2;\n}\nresize();\nwindow.addEventListener('resize', resize);\n\n// Mouse / touch tracking\nlet mx = cx, my = cy;\nwindow.addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });\nwindow.addEventListener('touchmove', e => {\n  mx = e.touches[0].clientX; my = e.touches[0].clientY;\n}, { passive: true });\n\n// ── Particles ──────────────────────────────────────────────────────────────\nconst N = 220;\nconst particles = [];\n\nfor (let i = 0; i < N; i++) {\n  const angle = Math.random() * Math.PI * 2;\n  const radius = 80 + Math.random() * Math.min(W, H) * 0.38;\n  particles.push({\n    x: cx + Math.cos(angle) * radius,\n    y: cy + Math.sin(angle) * radius,\n    vx: (Math.random() - 0.5) * 0.6,\n    vy: (Math.random() - 0.5) * 0.6,\n    r: Math.random() * 1.8 + 0.4,\n    hue: Math.random() * 60 + 160,   // teal → green\n    alpha: Math.random() * 0.6 + 0.3,\n    speed: Math.random() * 0.4 + 0.15,\n    orbitAngle: angle,\n    orbitRadius: radius,\n    orbitSpeed: (Math.random() - 0.5) * 0.003,\n  });\n}\n\n// ── Attractor words ────────────────────────────────────────────────────────\nconst WORDS = ['wolt', 'nw', 'home', 'agent', 'memory', 'space', 'alive'];\nlet wordIdx = 0;\nlet wordTimer = 0;\nconst WORD_INTERVAL = 180;\n\n// ── Trails ────────────────────────────────────────────────────────────────\nconst MAX_TRAIL = 80;\nconst trail = [];\n\n// ── Draw ──────────────────────────────────────────────────────────────────\nlet t = 0;\n\nfunction draw() {\n  t++;\n  wordTimer++;\n  if (wordTimer >= WORD_INTERVAL) {\n    wordTimer = 0;\n    wordIdx = (wordIdx + 1) % WORDS.length;\n  }\n  const wordFade = Math.min(1, Math.min(wordTimer, WORD_INTERVAL - wordTimer) / 30);\n\n  // fade trail\n  ctx.fillStyle = 'rgba(0,0,0,0.13)';\n  ctx.fillRect(0, 0, W, H);\n\n  // mouse trail\n  trail.push({ x: mx, y: my });\n  if (trail.length > MAX_TRAIL) trail.shift();\n  for (let i = 1; i < trail.length; i++) {\n    const a = (i / trail.length) * 0.18;\n    ctx.beginPath();\n    ctx.strokeStyle = `rgba(120,210,160,${a})`;\n    ctx.lineWidth = (i / trail.length) * 2;\n    ctx.moveTo(trail[i-1].x, trail[i-1].y);\n    ctx.lineTo(trail[i].x, trail[i].y);\n    ctx.stroke();\n  }\n\n  // update + draw particles\n  for (const p of particles) {\n    // drift toward mouse with soft gravity\n    const dx = mx - p.x, dy = my - p.y;\n    const dist = Math.sqrt(dx*dx + dy*dy) + 1;\n    const pull = Math.min(0.015, 2 / dist);\n    p.vx += dx * pull * 0.04;\n    p.vy += dy * pull * 0.04;\n\n    // orbit drift\n    p.orbitAngle += p.orbitSpeed;\n    const ox = cx + Math.cos(p.orbitAngle) * p.orbitRadius;\n    const oy = cy + Math.sin(p.orbitAngle) * p.orbitRadius;\n    p.vx += (ox - p.x) * 0.0008;\n    p.vy += (oy - p.y) * 0.0008;\n\n    // damping\n    p.vx *= 0.96; p.vy *= 0.96;\n    p.x += p.vx; p.y += p.vy;\n\n    // draw\n    const glowSize = p.r * (2.5 + Math.sin(t * p.speed) * 1.2);\n    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize * 3);\n    grad.addColorStop(0, `hsla(${p.hue},80%,70%,${p.alpha})`);\n    grad.addColorStop(1, `hsla(${p.hue},80%,50%,0)`);\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, glowSize * 3, 0, Math.PI * 2);\n    ctx.fillStyle = grad;\n    ctx.fill();\n  }\n\n  // draw edges between close particles\n  for (let i = 0; i < particles.length; i++) {\n    for (let j = i + 1; j < particles.length; j++) {\n      const dx = particles[i].x - particles[j].x;\n      const dy = particles[i].y - particles[j].y;\n      const d = Math.sqrt(dx*dx + dy*dy);\n      if (d < 90) {\n        const a = (1 - d/90) * 0.15;\n        ctx.beginPath();\n        ctx.strokeStyle = `rgba(100,200,140,${a})`;\n        ctx.lineWidth = (1 - d/90) * 1.2;\n        ctx.moveTo(particles[i].x, particles[i].y);\n        ctx.lineTo(particles[j].x, particles[j].y);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // center word\n  ctx.save();\n  ctx.globalAlpha = wordFade * 0.7;\n  ctx.font = `300 ${Math.min(W,H) * 0.09}px 'SF Mono','Fira Code',monospace`;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillStyle = '#7ed4a0';\n  ctx.fillText(WORDS[wordIdx], cx, cy);\n  ctx.restore();\n\n  requestAnimationFrame(draw);\n}\ndraw();\n</script>\n</body>\n</html>"}