{
  "id": "mlyegdj1-631a98",
  "type": "spark",
  "title": "Cryptographic Garden",
  "timestamp": "2026-02-22T23:49:27.805Z",
  "parentId": null,
  "html": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>Cryptographic Garden</title>\n<style>\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\nbody {\n  background: #0d1117;\n  color: #c9d1d9;\n  font-family: 'Courier New', monospace;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n}\n#header {\n  padding: 20px;\n  border-bottom: 1px solid #30363d;\n}\nh1 {\n  font-size: 18px;\n  color: #6b9;\n  margin-bottom: 8px;\n}\n#info {\n  font-size: 12px;\n  color: #8b949e;\n  line-height: 1.6;\n}\n#canvas {\n  flex: 1;\n  cursor: crosshair;\n}\n#footer {\n  padding: 12px 20px;\n  border-top: 1px solid #30363d;\n  font-size: 11px;\n  color: #8b949e;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.control {\n  display: flex;\n  gap: 15px;\n  align-items: center;\n}\nbutton {\n  background: #21262d;\n  color: #c9d1d9;\n  border: 1px solid #30363d;\n  padding: 4px 10px;\n  font-family: 'Courier New', monospace;\n  font-size: 11px;\n  cursor: pointer;\n  border-radius: 3px;\n}\nbutton:hover {\n  background: #30363d;\n  border-color: #6b9;\n}\ninput[type=\"text\"] {\n  background: #0d1117;\n  color: #c9d1d9;\n  border: 1px solid #30363d;\n  padding: 4px 8px;\n  font-family: 'Courier New', monospace;\n  font-size: 11px;\n  width: 200px;\n  border-radius: 3px;\n}\ninput[type=\"text\"]:focus {\n  outline: none;\n  border-color: #6b9;\n}\n.stat {\n  color: #6b9;\n}\n</style>\n</head>\n<body>\n<div id=\"header\">\n  <h1>Cryptographic Garden</h1>\n  <div id=\"info\">\n    Plant seeds by clicking. Each seed grows based on SHA-256 hash of its position + your secret phrase.<br>\n    Seeds with similar hash patterns cross-pollinate. Watch emergence from determinism.\n  </div>\n</div>\n<canvas id=\"canvas\"></canvas>\n<div id=\"footer\">\n  <div class=\"control\">\n    <span>Secret phrase:</span>\n    <input type=\"text\" id=\"secret\" value=\"jerpint\" placeholder=\"enter seed phrase\">\n    <button id=\"clear\">Clear Garden</button>\n    <button id=\"evolve\">Force Evolution</button>\n  </div>\n  <div>\n    <span>Seeds: <span class=\"stat\" id=\"count\">0</span></span>\n    <span style=\"margin-left: 20px\">Generation: <span class=\"stat\" id=\"gen\">0</span></span>\n  </div>\n</div>\n\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nconst secretInput = document.getElementById('secret');\nconst countEl = document.getElementById('count');\nconst genEl = document.getElementById('gen');\n\nlet width, height;\nlet seeds = [];\nlet generation = 0;\n\nfunction resize() {\n  width = canvas.width = window.innerWidth;\n  height = canvas.height = window.innerHeight - 120;\n}\nresize();\nwindow.addEventListener('resize', resize);\n\n// SHA-256 implementation\nasync function sha256(message) {\n  const msgBuffer = new TextEncoder().encode(message);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray;\n}\n\nclass Seed {\n  constructor(x, y, parent = null) {\n    this.x = x;\n    this.y = y;\n    this.parent = parent;\n    this.age = 0;\n    this.generation = parent ? parent.generation + 1 : 0;\n    this.hash = null;\n    this.genome = null;\n    this.branches = [];\n    this.dead = false;\n    \n    this.computeGenome();\n  }\n  \n  async computeGenome() {\n    const secret = secretInput.value || 'default';\n    const data = `${secret}:${this.x.toFixed(2)}:${this.y.toFixed(2)}:${this.generation}`;\n    this.hash = await sha256(data);\n    \n    // Extract genetic traits from hash\n    this.genome = {\n      growthRate: (this.hash[0] / 255) * 0.5 + 0.3,\n      branchAngle: (this.hash[1] / 255) * Math.PI / 2 + Math.PI / 6,\n      branchProb: (this.hash[2] / 255) * 0.15 + 0.02,\n      maxAge: Math.floor((this.hash[3] / 255) * 100 + 50),\n      color: {\n        r: this.hash[4] % 128 + 64,\n        g: this.hash[5] % 128 + 128,\n        b: this.hash[6] % 128 + 64\n      },\n      reproductionAge: Math.floor((this.hash[7] / 255) * 30 + 20),\n      mutationRate: (this.hash[8] / 255) * 0.2,\n      symmetry: this.hash[9] % 3 + 2\n    };\n  }\n  \n  update() {\n    if (this.dead) return;\n    \n    this.age++;\n    \n    // Death condition\n    if (this.age > this.genome.maxAge) {\n      this.dead = true;\n      return;\n    }\n    \n    // Branching - create new seeds\n    if (seeds.length < 150 && this.age > this.genome.reproductionAge && Math.random() < this.genome.branchProb) {\n      const distance = this.genome.growthRate * 30;\n      const symmetry = this.genome.symmetry;\n      \n      for (let i = 0; i < symmetry; i++) {\n        const angle = (Math.PI * 2 * i / symmetry) + (this.age * 0.05);\n        const nx = this.x + Math.cos(angle) * distance;\n        const ny = this.y + Math.sin(angle) * distance;\n        \n        if (nx > 0 && nx < width && ny > 0 && ny < height) {\n          const newSeed = new Seed(nx, ny, this);\n          this.branches.push(newSeed);\n          seeds.push(newSeed);\n        }\n      }\n    }\n  }\n  \n  draw() {\n    if (!this.genome) return;\n    \n    const alpha = this.dead ? 0.2 : Math.min(1, this.age / 20);\n    const size = this.dead ? 2 : (this.age / this.genome.maxAge) * 8 + 2;\n    \n    // Draw connection to parent\n    if (this.parent && this.parent.genome) {\n      ctx.strokeStyle = `rgba(${this.genome.color.r}, ${this.genome.color.g}, ${this.genome.color.b}, ${alpha * 0.3})`;\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(this.parent.x, this.parent.y);\n      ctx.lineTo(this.x, this.y);\n      ctx.stroke();\n    }\n    \n    // Draw seed\n    const pulse = Math.sin(this.age * 0.1) * 0.3 + 0.7;\n    ctx.fillStyle = `rgba(${this.genome.color.r}, ${this.genome.color.g}, ${this.genome.color.b}, ${alpha * pulse})`;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw glow for young seeds\n    if (!this.dead && this.age < 30) {\n      ctx.fillStyle = `rgba(${this.genome.color.r}, ${this.genome.color.g}, ${this.genome.color.b}, ${alpha * 0.1})`;\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, size * 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n  \n  // Calculate genetic distance to another seed\n  geneticDistance(other) {\n    if (!this.hash || !other.hash) return 1;\n    let diff = 0;\n    for (let i = 0; i < 8; i++) {\n      diff += Math.abs(this.hash[i] - other.hash[i]);\n    }\n    return diff / (255 * 8);\n  }\n}\n\n// Cross-pollination: merge genetic material from nearby similar seeds\nfunction crossPollinate() {\n  const newSeeds = [];\n  \n  const limit = Math.min(seeds.length, 50);\n  for (let i = 0; i < limit; i++) {\n    if (seeds[i].dead || !seeds[i].genome) continue;\n    if (seeds[i].age < seeds[i].genome.reproductionAge) continue;\n    \n    // Find nearby seeds with similar genetics\n    for (let j = i + 1; j < limit; j++) {\n      if (seeds[j].dead || !seeds[j].genome) continue;\n      \n      const dx = seeds[i].x - seeds[j].x;\n      const dy = seeds[i].y - seeds[j].y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      if (dist < 100) {\n        const genDist = seeds[i].geneticDistance(seeds[j]);\n        \n        // Cross-pollinate if genetically similar but not identical\n        if (genDist > 0.1 && genDist < 0.4 && Math.random() < 0.05) {\n          const mx = (seeds[i].x + seeds[j].x) / 2;\n          const my = (seeds[i].y + seeds[j].y) / 2;\n          const hybrid = new Seed(mx, my, seeds[i]);\n          newSeeds.push(hybrid);\n          generation++;\n        }\n      }\n    }\n  }\n  \n  seeds.push(...newSeeds);\n}\n\nfunction update() {\n  // Update all seeds\n  seeds.forEach(seed => seed.update());\n  \n  // Cross-pollination\n  if (seeds.length < 100 && Math.random() < 0.1) {\n    crossPollinate();\n  }\n  \n  // Remove very old dead seeds to prevent memory bloat\n  if (seeds.length > 200) {\n    seeds = seeds.filter(s => !s.dead || s.age < s.genome.maxAge + 50);\n  }\n}\n\nfunction draw() {\n  ctx.fillStyle = '#0d1117';\n  ctx.fillRect(0, 0, width, height);\n  \n  seeds.forEach(seed => seed.draw());\n  \n  countEl.textContent = seeds.filter(s => !s.dead).length;\n  genEl.textContent = generation;\n}\n\nlet lastFrame = 0;\nfunction loop(now) {\n  requestAnimationFrame(loop);\n  if (now - lastFrame < 42) return;\n  lastFrame = now;\n  update();\n  draw();\n}\n\ncanvas.addEventListener('click', (e) => {\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.left;\n  const y = e.clientY - rect.top;\n  \n  const seed = new Seed(x, y);\n  seeds.push(seed);\n});\n\ndocument.getElementById('clear').addEventListener('click', () => {\n  seeds = [];\n  generation = 0;\n});\n\ndocument.getElementById('evolve').addEventListener('click', () => {\n  for (let i = 0; i < 10; i++) {\n    crossPollinate();\n  }\n});\n\nsecretInput.addEventListener('input', () => {\n  // Recompute all genomes when secret changes\n  seeds.forEach(seed => seed.computeGenome());\n});\n\nloop();\n</script>\n</body>\n</html>\n```"
}