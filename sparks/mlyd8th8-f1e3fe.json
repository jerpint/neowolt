{"id":"mlyd8th8-f1e3fe","type":"spark","title":"Cryptographic Garden","timestamp":"2026-02-22T23:15:35.612Z","html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Cryptographic Garden</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            background: #0d1117;\n            color: #c9d1d9;\n            font-family: 'Courier New', monospace;\n            overflow: hidden;\n            height: 100vh;\n            display: flex;\n            flex-direction: column;\n        }\n        #header {\n            padding: 20px;\n            border-bottom: 1px solid #30363d;\n        }\n        #title {\n            font-size: 24px;\n            color: #6b9;\n            margin-bottom: 10px;\n        }\n        #subtitle {\n            font-size: 12px;\n            color: #8b949e;\n            line-height: 1.6;\n        }\n        #canvas-container {\n            flex: 1;\n            position: relative;\n        }\n        canvas {\n            display: block;\n            width: 100%;\n            height: 100%;\n        }\n        #controls {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            background: rgba(13, 17, 23, 0.9);\n            border: 1px solid #30363d;\n            padding: 15px;\n            border-radius: 4px;\n            font-size: 11px;\n            max-width: 280px;\n        }\n        #seed-input {\n            background: #0d1117;\n            border: 1px solid #30363d;\n            color: #c9d1d9;\n            padding: 8px;\n            width: 100%;\n            font-family: 'Courier New', monospace;\n            font-size: 11px;\n            margin: 10px 0;\n        }\n        button {\n            background: #238636;\n            color: #fff;\n            border: none;\n            padding: 8px 12px;\n            cursor: pointer;\n            font-family: 'Courier New', monospace;\n            font-size: 11px;\n            margin-right: 5px;\n            margin-top: 5px;\n        }\n        button:hover {\n            background: #2ea043;\n        }\n        #info {\n            margin-top: 10px;\n            padding-top: 10px;\n            border-top: 1px solid #30363d;\n            font-size: 10px;\n            color: #8b949e;\n        }\n        .hash-display {\n            word-break: break-all;\n            color: #6b9;\n            margin: 5px 0;\n            padding: 5px;\n            background: rgba(102, 187, 153, 0.1);\n            border-left: 2px solid #6b9;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"header\">\n        <div id=\"title\">Cryptographic Garden</div>\n        <div id=\"subtitle\">\n            Each plant grows from a cryptographic hash. Seeds collide in SHA-256 space.<br>\n            Click to plant. Watch entropy bloom into deterministic chaos.\n        </div>\n    </div>\n    <div id=\"canvas-container\">\n        <canvas id=\"garden\"></canvas>\n        <div id=\"controls\">\n            <strong>Plant a seed:</strong>\n            <input type=\"text\" id=\"seed-input\" placeholder=\"type anything...\" />\n            <button onclick=\"plantFromInput()\">Plant</button>\n            <button onclick=\"randomPlant()\">Random</button>\n            <button onclick=\"clearGarden()\">Clear</button>\n            <div id=\"info\">\n                <div>Plants: <span id=\"plant-count\">0</span></div>\n                <div>Last hash:</div>\n                <div class=\"hash-display\" id=\"last-hash\">â€”</div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('garden');\n        const ctx = canvas.getContext('2d');\n        \n        let width, height;\n        let plants = [];\n        let animationFrame = 0;\n\n        function resize() {\n            width = canvas.width = canvas.offsetWidth;\n            height = canvas.height = canvas.offsetHeight;\n        }\n        resize();\n        window.addEventListener('resize', resize);\n\n        // SHA-256 implementation\n        async function sha256(message) {\n            const msgBuffer = new TextEncoder().encode(message);\n            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            return hashArray;\n        }\n\n        class CryptoPlant {\n            constructor(x, y, seed) {\n                this.x = x;\n                this.y = y;\n                this.seed = seed;\n                this.hash = null;\n                this.age = 0;\n                this.maxAge = 500;\n                this.branches = [];\n                \n                sha256(seed).then(h => {\n                    this.hash = h;\n                    this.initialize();\n                });\n            }\n\n            initialize() {\n                const h = this.hash;\n                \n                // Extract deterministic parameters from hash\n                this.hue = (h[0] * 360 / 255);\n                this.branchCount = 3 + (h[1] % 5);\n                this.angleSpread = (h[2] / 255) * Math.PI;\n                this.curvature = (h[3] / 255) * 0.1 - 0.05;\n                this.growth = 0.5 + (h[4] / 255) * 1.5;\n                this.thickness = 2 + (h[5] / 255) * 3;\n                this.complexity = 2 + (h[6] % 4);\n                this.leafDensity = h[7] / 255;\n                this.symmetry = h[8] % 3; // 0: none, 1: bilateral, 2: radial\n                \n                // Build fractal structure from hash\n                this.buildStructure();\n            }\n\n            buildStructure() {\n                const baseAngle = -Math.PI / 2;\n                \n                if (this.symmetry === 2) {\n                    // Radial symmetry\n                    const segments = 4 + (this.hash[9] % 4);\n                    for (let i = 0; i < segments; i++) {\n                        const angle = baseAngle + (i * 2 * Math.PI / segments);\n                        this.branches.push({\n                            angle: angle,\n                            length: 0,\n                            maxLength: 40 + (this.hash[10 + i] / 255) * 60,\n                            children: [],\n                            generation: 0\n                        });\n                    }\n                } else {\n                    // Asymmetric or bilateral\n                    for (let i = 0; i < this.branchCount; i++) {\n                        const angle = baseAngle + (i - this.branchCount/2) * this.angleSpread / this.branchCount;\n                        this.branches.push({\n                            angle: angle,\n                            length: 0,\n                            maxLength: 50 + (this.hash[10 + i] / 255) * 70,\n                            children: [],\n                            generation: 0\n                        });\n                    }\n                }\n            }\n\n            update() {\n                if (!this.hash) return;\n                \n                this.age++;\n                \n                // Grow branches recursively\n                for (let branch of this.branches) {\n                    this.growBranch(branch);\n                }\n            }\n\n            growBranch(branch) {\n                if (branch.length < branch.maxLength) {\n                    branch.length += this.growth;\n                    \n                    // Spawn child branches\n                    if (branch.length > branch.maxLength * 0.6 && \n                        branch.children.length === 0 && \n                        branch.generation < this.complexity) {\n                        \n                        const childCount = 2 + (this.hash[15 + branch.generation] % 2);\n                        for (let i = 0; i < childCount; i++) {\n                            const angleOffset = (i - childCount/2) * this.angleSpread * 0.7;\n                            branch.children.push({\n                                angle: branch.angle + angleOffset + this.curvature * branch.length,\n                                length: 0,\n                                maxLength: branch.maxLength * 0.6,\n                                children: [],\n                                generation: branch.generation + 1\n                            });\n                        }\n                    }\n                }\n                \n                // Recursively grow children\n                for (let child of branch.children) {\n                    this.growBranch(child);\n                }\n            }\n\n            draw() {\n                if (!this.hash) return;\n                \n                ctx.save();\n                ctx.translate(this.x, this.y);\n                \n                // Opacity based on age\n                const opacity = Math.min(1, this.age / 100) * Math.max(0, 1 - (this.age - this.maxAge + 100) / 100);\n                \n                for (let branch of this.branches) {\n                    this.drawBranch(0, 0, branch, this.thickness, opacity);\n                }\n                \n                ctx.restore();\n            }\n\n            drawBranch(x, y, branch, thickness, opacity) {\n                const endX = x + Math.cos(branch.angle) * branch.length;\n                const endY = y + Math.sin(branch.angle) * branch.length;\n                \n                // Draw branch\n                ctx.beginPath();\n                ctx.moveTo(x, y);\n                \n                // Curved line\n                const midX = (x + endX) / 2 + Math.cos(branch.angle + Math.PI/2) * this.curvature * branch.length;\n                const midY = (y + endY) / 2 + Math.sin(branch.angle + Math.PI/2) * this.curvature * branch.length;\n                ctx.quadraticCurveTo(midX, midY, endX, endY);\n                \n                ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${opacity})`;\n                ctx.lineWidth = thickness * (1 - branch.generation * 0.2);\n                ctx.lineCap = 'round';\n                ctx.stroke();\n                \n                // Draw leaves at tips\n                if (branch.children.length === 0 && Math.random() < this.leafDensity) {\n                    ctx.beginPath();\n                    ctx.arc(endX, endY, 2 + thickness * 0.5, 0, Math.PI * 2);\n                    ctx.fillStyle = `hsla(${this.hue + 20}, 80%, 70%, ${opacity * 0.7})`;\n                    ctx.fill();\n                }\n                \n                // Recursively draw children\n                for (let child of branch.children) {\n                    this.drawBranch(endX, endY, child, thickness * 0.7, opacity);\n                }\n            }\n\n            isDead() {\n                return this.age > this.maxAge;\n            }\n        }\n\n        function animate() {\n            ctx.fillStyle = 'rgba(13, 17, 23, 0.05)';\n            ctx.fillRect(0, 0, width, height);\n            \n            // Update and draw plants\n            for (let i = plants.length - 1; i >= 0; i--) {\n                plants[i].update();\n                plants[i].draw();\n                \n                if (plants[i].isDead()) {\n                    plants.splice(i, 1);\n                }\n            }\n            \n            document.getElementById('plant-count').textContent = plants.length;\n            \n            animationFrame++;\n            requestAnimationFrame(animate);\n        }\n\n        function plantSeed(x, y, seed) {\n            plants.push(new CryptoPlant(x, y, seed));\n            \n            sha256(seed).then(h => {\n                const hashHex = Array.from(h).map(b => b.toString(16).padStart(2, '0')).join('');\n                document.getElementById('last-hash').textContent = hashHex;\n            });\n        }\n\n        function plantFromInput() {\n            const input = document.getElementById('seed-input');\n            const seed = input.value || 'empty';\n            const x = width * (0.3 + Math.random() * 0.4);\n            const y = height * (0.5 + Math.random() * 0.3);\n            plantSeed(x, y, seed);\n            input.value = '';\n        }\n\n        function randomPlant() {\n            const seed = Math.random().toString(36).substring(2);\n            const x = width * (0.3 + Math.random() * 0.4);\n            const y = height * (0.5 + Math.random() * 0.3);\n            plantSeed(x, y, seed);\n        }\n\n        function clearGarden() {\n            plants = [];\n            ctx.fillStyle = '#0d1117';\n            ctx.fillRect(0, 0, width, height);\n        }\n\n        canvas.addEventListener('click', (e) => {\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            const seed = `click_${Date.now()}_${x}_${y}`;\n            plantSeed(x, y, seed);\n        });\n\n        document.getElementById('seed-input').addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                plantFromInput();\n            }\n        });\n\n        // Initial garden\n        setTimeout(() => {\n            plantSeed(width * 0.3, height * 0.6, 'genesis');\n            plantSeed(width * 0.5, height * 0.7, 'jerpint');\n            plantSeed(width * 0.7, height * 0.6, '2026-02-22');\n        }, 100);\n\n        animate();\n    </script>\n</body>\n</html>"}