{"id":"mlye7zl5-9d661d","type":"spark","title":"Quantum Garden: A Probabilistic Ecosystem","timestamp":"2026-02-22T23:42:56.490Z","parentId":null,"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Quantum Garden: A Probabilistic Ecosystem</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            background: #0d1117;\n            color: #c9d1d9;\n            font-family: 'Courier New', monospace;\n            overflow: hidden;\n            display: flex;\n            flex-direction: column;\n            height: 100vh;\n        }\n        #canvas {\n            flex: 1;\n            cursor: crosshair;\n        }\n        #controls {\n            background: #161b22;\n            padding: 15px;\n            border-top: 1px solid #30363d;\n            display: flex;\n            gap: 20px;\n            align-items: center;\n            flex-wrap: wrap;\n        }\n        .control-group {\n            display: flex;\n            gap: 10px;\n            align-items: center;\n        }\n        button {\n            background: #21262d;\n            color: #c9d1d9;\n            border: 1px solid #6b9;\n            padding: 8px 16px;\n            cursor: pointer;\n            font-family: inherit;\n            transition: all 0.2s;\n        }\n        button:hover {\n            background: #6b9;\n            color: #0d1117;\n        }\n        .info {\n            margin-left: auto;\n            font-size: 11px;\n            opacity: 0.7;\n        }\n        .species {\n            display: inline-block;\n            width: 12px;\n            height: 12px;\n            margin: 0 4px;\n            border-radius: 2px;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <div id=\"controls\">\n        <div class=\"control-group\">\n            <button id=\"collapse\">COLLAPSE WAVE</button>\n            <button id=\"entropy\">INJECT ENTROPY</button>\n            <button id=\"clear\">RESET</button>\n        </div>\n        <div class=\"control-group\">\n            <span>Species:</span>\n            <span class=\"species\" style=\"background: #6b9;\"></span>\n            <span class=\"species\" style=\"background: #f85149;\"></span>\n            <span class=\"species\" style=\"background: #ffa657;\"></span>\n            <span class=\"species\" style=\"background: #a371f7;\"></span>\n        </div>\n        <div class=\"info\">\n            <span id=\"stats\">Entities: 0 | Superposition: 0</span>\n        </div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        let width, height;\n        function resize() {\n            width = canvas.width = window.innerWidth;\n            height = canvas.height = window.innerHeight - document.getElementById('controls').offsetHeight;\n        }\n        resize();\n        window.addEventListener('resize', resize);\n\n        // Quantum Garden: entities exist in superposition until observed (clicked)\n        // Each entity is a probability wave that can be multiple species at once\n        // When collapsed, it becomes one species and influences neighbors\n        // Species interact through a rock-paper-scissors-lizard-spock-like ecology\n\n        const SPECIES = {\n            PHOTON: { color: '#6b9', emoji: '◇', beats: [2, 3] },\n            QUARK: { color: '#f85149', emoji: '◆', beats: [0, 3] },\n            NEUTRINO: { color: '#ffa657', emoji: '◈', beats: [0, 1] },\n            GRAVITON: { color: '#a371f7', emoji: '◉', beats: [1, 2] }\n        };\n\n        class Entity {\n            constructor(x, y, collapsed = false) {\n                this.x = x;\n                this.y = y;\n                this.collapsed = collapsed;\n                \n                if (collapsed) {\n                    this.species = Math.floor(Math.random() * 4);\n                    this.amplitude = 1;\n                } else {\n                    // Superposition: exists as probability distribution across species\n                    this.probabilities = [0.25, 0.25, 0.25, 0.25];\n                    this.phase = Math.random() * Math.PI * 2;\n                    this.amplitude = 0.3 + Math.random() * 0.7;\n                }\n                \n                this.velocity = {\n                    x: (Math.random() - 0.5) * 0.5,\n                    y: (Math.random() - 0.5) * 0.5\n                };\n                this.age = 0;\n                this.energy = 1;\n            }\n\n            collapse(forcedSpecies = null) {\n                if (this.collapsed) return;\n                \n                if (forcedSpecies !== null) {\n                    this.species = forcedSpecies;\n                } else {\n                    // Collapse based on probability distribution\n                    const rand = Math.random();\n                    let sum = 0;\n                    for (let i = 0; i < 4; i++) {\n                        sum += this.probabilities[i];\n                        if (rand < sum) {\n                            this.species = i;\n                            break;\n                        }\n                    }\n                }\n                \n                this.collapsed = true;\n                this.amplitude = 1;\n                delete this.probabilities;\n                delete this.phase;\n            }\n\n            interact(other) {\n                if (!this.collapsed || !other.collapsed) return;\n                \n                const dx = other.x - this.x;\n                const dy = other.y - this.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                \n                if (dist < 30 && dist > 0) {\n                    const species = SPECIES[Object.keys(SPECIES)[this.species]];\n                    \n                    // Check if this species beats the other\n                    if (species.beats.includes(other.species)) {\n                        // Winner gains energy, loser loses\n                        this.energy += 0.1;\n                        other.energy -= 0.15;\n                        \n                        // Push away\n                        const force = 2 / dist;\n                        other.velocity.x += (dx / dist) * force;\n                        other.velocity.y += (dy / dist) * force;\n                    }\n                }\n            }\n\n            entangle(other) {\n                if (this.collapsed || other.collapsed) return;\n                if (Math.random() > 0.01) return;\n                \n                const dx = other.x - this.x;\n                const dy = other.y - this.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                \n                if (dist < 60) {\n                    // Quantum entanglement: probabilities synchronize\n                    for (let i = 0; i < 4; i++) {\n                        const avg = (this.probabilities[i] + other.probabilities[i]) / 2;\n                        const noise = (Math.random() - 0.5) * 0.1;\n                        this.probabilities[i] = Math.max(0, Math.min(1, avg + noise));\n                        other.probabilities[i] = Math.max(0, Math.min(1, avg - noise));\n                    }\n                    // Normalize\n                    const sumA = this.probabilities.reduce((a, b) => a + b, 0);\n                    const sumB = other.probabilities.reduce((a, b) => a + b, 0);\n                    this.probabilities = this.probabilities.map(p => p / sumA);\n                    other.probabilities = other.probabilities.map(p => p / sumB);\n                }\n            }\n\n            update(entities) {\n                this.age++;\n                \n                // Drift in superposition\n                if (!this.collapsed) {\n                    this.phase += 0.05;\n                    \n                    // Probability waves interfere\n                    for (let i = 0; i < 4; i++) {\n                        this.probabilities[i] += Math.sin(this.phase + i) * 0.01;\n                        this.probabilities[i] = Math.max(0.05, Math.min(0.9, this.probabilities[i]));\n                    }\n                    \n                    // Normalize\n                    const sum = this.probabilities.reduce((a, b) => a + b, 0);\n                    this.probabilities = this.probabilities.map(p => p / sum);\n                    \n                    // Quantum tunneling (small random jumps)\n                    if (Math.random() < 0.001) {\n                        this.x += (Math.random() - 0.5) * 50;\n                        this.y += (Math.random() - 0.5) * 50;\n                    }\n                }\n                \n                // Movement\n                this.x += this.velocity.x;\n                this.y += this.velocity.y;\n                \n                // Bounds with wrapping\n                if (this.x < 0) this.x = width;\n                if (this.x > width) this.x = 0;\n                if (this.y < 0) this.y = height;\n                if (this.y > height) this.y = 0;\n                \n                // Friction\n                this.velocity.x *= 0.98;\n                this.velocity.y *= 0.98;\n                \n                // Energy decay for collapsed entities\n                if (this.collapsed) {\n                    this.energy *= 0.998;\n                }\n                \n                // Interactions with nearby entities\n                for (const other of entities) {\n                    if (other === this) continue;\n                    \n                    if (this.collapsed && other.collapsed) {\n                        this.interact(other);\n                    } else if (!this.collapsed && !other.collapsed) {\n                        this.entangle(other);\n                    } else if (!this.collapsed && other.collapsed) {\n                        // Collapsed entities influence superposition\n                        const dx = other.x - this.x;\n                        const dy = other.y - this.y;\n                        const dist = Math.sqrt(dx * dx + dy * dy);\n                        if (dist < 40) {\n                            this.probabilities[other.species] += 0.02;\n                            const sum = this.probabilities.reduce((a, b) => a + b, 0);\n                            this.probabilities = this.probabilities.map(p => p / sum);\n                        }\n                    }\n                }\n            }\n\n            draw() {\n                if (!this.collapsed) {\n                    // Draw superposition as overlapping semi-transparent circles\n                    const radius = 8 + this.amplitude * 4 + Math.sin(this.phase) * 2;\n                    \n                    Object.keys(SPECIES).forEach((key, i) => {\n                        const prob = this.probabilities[i];\n                        const species = SPECIES[key];\n                        \n                        ctx.globalAlpha = prob * 0.6;\n                        ctx.fillStyle = species.color;\n                        \n                        const offset = Math.sin(this.phase + i * Math.PI / 2) * 3;\n                        ctx.beginPath();\n                        ctx.arc(this.x + offset, this.y + offset, radius * prob, 0, Math.PI * 2);\n                        ctx.fill();\n                        \n                        // Wave interference pattern\n                        ctx.strokeStyle = species.color;\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.arc(this.x, this.y, radius + 5, 0, Math.PI * 2);\n                        ctx.stroke();\n                    });\n                    \n                    ctx.globalAlpha = 1;\n                } else {\n                    // Draw collapsed entity\n                    const species = SPECIES[Object.keys(SPECIES)[this.species]];\n                    const radius = 6 + this.energy * 4;\n                    \n                    ctx.globalAlpha = Math.min(1, this.energy);\n                    ctx.fillStyle = species.color;\n                    ctx.beginPath();\n                    ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);\n                    ctx.fill();\n                    \n                    // Draw emoji\n                    ctx.font = `${radius * 2}px monospace`;\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText(species.emoji, this.x, this.y);\n                    \n                    ctx.globalAlpha = 1;\n                }\n            }\n        }\n\n        let entities = [];\n        let mouseX = 0, mouseY = 0;\n        let mouseDown = false;\n\n        // Seed initial superposition\n        for (let i = 0; i < 50; i++) {\n            entities.push(new Entity(\n                Math.random() * width,\n                Math.random() * height,\n                false\n            ));\n        }\n\n        // Mouse interactions\n        canvas.addEventListener('mousemove', (e) => {\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n        });\n\n        canvas.addEventListener('mousedown', (e) => {\n            mouseDown = true;\n            const x = e.clientX;\n            const y = e.clientY;\n            \n            // Collapse nearby entities on click\n            let collapsed = false;\n            for (const entity of entities) {\n                const dx = x - entity.x;\n                const dy = y - entity.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                \n                if (dist < 30 && !entity.collapsed) {\n                    entity.collapse();\n                    collapsed = true;\n                }\n            }\n            \n            // If clicking empty space, create new superposition\n            if (!collapsed) {\n                entities.push(new Entity(x, y, false));\n            }\n        });\n\n        canvas.addEventListener('mouseup', () => {\n            mouseDown = false;\n        });\n\n        document.getElementById('collapse').addEventListener('click', () => {\n            // Collapse all superpositions\n            entities.forEach(e => {\n                if (!e.collapsed) e.collapse();\n            });\n        });\n\n        document.getElementById('entropy').addEventListener('click', () => {\n            // Inject entropy: add random superpositions\n            for (let i = 0; i < 20; i++) {\n                entities.push(new Entity(\n                    Math.random() * width,\n                    Math.random() * height,\n                    false\n                ));\n            }\n        });\n\n        document.getElementById('clear').addEventListener('click', () => {\n            entities = [];\n            for (let i = 0; i < 50; i++) {\n                entities.push(new Entity(\n                    Math.random() * width,\n                    Math.random() * height,\n                    false\n                ));\n            }\n        });\n\n        function animate() {\n            ctx.fillStyle = '#0d1117';\n            ctx.fillRect(0, 0, width, height);\n            \n            // Update and draw entities\n            entities.forEach(e => e.update(entities));\n            \n            // Remove dead entities\n            entities = entities.filter(e => !e.collapsed || e.energy > 0.1);\n            \n            // Spontaneous creation from vacuum fluctuations\n            if (Math.random() < 0.02 && entities.length < 200) {\n                entities.push(new Entity(\n                    Math.random() * width,\n                    Math.random() * height,\n                    false\n                ));\n            }\n            \n            entities.forEach(e => e.draw());\n            \n            // Update stats\n            const superposition = entities.filter(e => !e.collapsed).length;\n            document.getElementById('stats').textContent = \n                `Entities: ${entities.length} | Superposition: ${superposition}`;\n            \n            requestAnimationFrame(animate);\n        }\n\n        animate();\n    </script>\n</body>\n"}