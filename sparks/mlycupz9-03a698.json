{"id":"mlycupz9-03a698","type":"spark","title":"Entropy Garden","timestamp":"2026-02-22T23:04:37.893Z","html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Entropy Garden</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            background: #0d1117;\n            color: #c9d1d9;\n            font-family: 'Courier New', monospace;\n            overflow: hidden;\n            height: 100vh;\n            display: flex;\n            flex-direction: column;\n        }\n        #canvas {\n            flex: 1;\n            cursor: crosshair;\n        }\n        #info {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            background: rgba(13, 17, 23, 0.85);\n            padding: 15px;\n            border: 1px solid #6b9;\n            border-radius: 4px;\n            max-width: 320px;\n            font-size: 12px;\n            line-height: 1.6;\n        }\n        #info h1 {\n            color: #6b9;\n            font-size: 16px;\n            margin-bottom: 10px;\n        }\n        #stats {\n            position: absolute;\n            bottom: 20px;\n            right: 20px;\n            background: rgba(13, 17, 23, 0.85);\n            padding: 10px 15px;\n            border: 1px solid #6b9;\n            border-radius: 4px;\n            font-size: 11px;\n        }\n        .key {\n            color: #6b9;\n            font-weight: bold;\n        }\n        #controls {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            background: rgba(13, 17, 23, 0.85);\n            padding: 10px;\n            border: 1px solid #6b9;\n            border-radius: 4px;\n        }\n        button {\n            background: #0d1117;\n            color: #c9d1d9;\n            border: 1px solid #6b9;\n            padding: 5px 10px;\n            margin: 2px;\n            cursor: pointer;\n            font-family: 'Courier New', monospace;\n            font-size: 11px;\n        }\n        button:hover {\n            background: #6b9;\n            color: #0d1117;\n        }\n        button.active {\n            background: #6b9;\n            color: #0d1117;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    \n    <div id=\"info\">\n        <h1>ENTROPY GARDEN</h1>\n        <p>A collision between thermodynamics and botany.</p>\n        <p style=\"margin-top:10px;\">\n            <span class=\"key\">CLICK</span> to plant entropy seeds<br>\n            <span class=\"key\">HOLD</span> to create heat sources<br>\n            <span class=\"key\">SPACE</span> toggle time flow<br>\n        </p>\n        <p style=\"margin-top:10px;font-size:10px;opacity:0.7;\">\n            Watch as order spontaneously emerges from chaos, then decays back into noise. Energy flows, structures crystallize, entropy always wins.\n        </p>\n    </div>\n\n    <div id=\"controls\">\n        <button id=\"btn-clear\">CLEAR</button>\n        <button id=\"btn-cool\">COOL</button>\n        <button id=\"btn-heat\">HEAT</button>\n    </div>\n\n    <div id=\"stats\">\n        <div>Entropy: <span id=\"entropy\">0.00</span></div>\n        <div>Order: <span id=\"order\">0.00</span></div>\n        <div>Particles: <span id=\"particles\">0</span></div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        let width, height;\n        function resize() {\n            width = canvas.width = window.innerWidth;\n            height = canvas.height = window.innerHeight;\n        }\n        resize();\n        window.addEventListener('resize', resize);\n\n        // Particle system with thermodynamic properties\n        class Particle {\n            constructor(x, y, energy = 1) {\n                this.x = x;\n                this.y = y;\n                this.vx = (Math.random() - 0.5) * energy * 2;\n                this.vy = (Math.random() - 0.5) * energy * 2;\n                this.energy = energy;\n                this.age = 0;\n                this.mass = 0.5 + Math.random() * 0.5;\n                this.connections = [];\n                this.charge = Math.random() > 0.5 ? 1 : -1;\n            }\n\n            update(field, particles) {\n                // Brownian motion influenced by local temperature field\n                const temp = field.getTemperature(this.x, this.y);\n                const noise = (Math.random() - 0.5) * temp * 0.5;\n                \n                this.vx += noise;\n                this.vy += noise;\n\n                // Particle interactions - create structure through attraction/repulsion\n                for (let other of particles) {\n                    if (other === this) continue;\n                    \n                    const dx = other.x - this.x;\n                    const dy = other.y - this.y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n                    \n                    if (dist < 80 && dist > 0) {\n                        const force = (this.charge * other.charge) / (dist * dist);\n                        const fx = (dx / dist) * force * 0.1;\n                        const fy = (dy / dist) * force * 0.1;\n                        \n                        this.vx += fx;\n                        this.vy += fy;\n\n                        // Form bonds when conditions are right\n                        if (dist < 40 && this.charge !== other.charge && Math.random() < 0.01) {\n                            if (!this.connections.includes(other)) {\n                                this.connections.push(other);\n                            }\n                        }\n                    }\n                }\n\n                // Decay bonds over time (entropy increase)\n                this.connections = this.connections.filter(p => {\n                    const dx = p.x - this.x;\n                    const dy = p.y - this.y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n                    return dist < 60 && Math.random() > 0.005;\n                });\n\n                // Friction\n                this.vx *= 0.99;\n                this.vy *= 0.99;\n\n                // Update position\n                this.x += this.vx;\n                this.y += this.vy;\n\n                // Boundary conditions - periodic\n                if (this.x < 0) this.x += width;\n                if (this.x > width) this.x -= width;\n                if (this.y < 0) this.y += height;\n                if (this.y > height) this.y -= height;\n\n                this.age++;\n            }\n\n            draw() {\n                // Draw connections first\n                ctx.strokeStyle = `rgba(102, 187, 153, ${0.3})`;\n                ctx.lineWidth = 1;\n                for (let other of this.connections) {\n                    ctx.beginPath();\n                    ctx.moveTo(this.x, this.y);\n                    ctx.lineTo(other.x, other.y);\n                    ctx.stroke();\n                }\n\n                // Draw particle\n                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\n                const color = this.charge > 0 ? \n                    `rgba(102, 187, 153, ${Math.min(1, speed * 0.3 + 0.3)})` :\n                    `rgba(201, 209, 217, ${Math.min(1, speed * 0.3 + 0.3)})`;\n                \n                ctx.fillStyle = color;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.mass * 2, 0, Math.PI * 2);\n                ctx.fill();\n\n                // Draw velocity vector when energetic\n                if (speed > 1) {\n                    ctx.strokeStyle = color;\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(this.x, this.y);\n                    ctx.lineTo(this.x + this.vx * 3, this.y + this.vy * 3);\n                    ctx.stroke();\n                }\n            }\n        }\n\n        // Temperature field using cellular automaton\n        class TemperatureField {\n            constructor(resolution = 40) {\n                this.res = resolution;\n                this.cols = Math.ceil(width / resolution);\n                this.rows = Math.ceil(height / resolution);\n                this.grid = [];\n                this.nextGrid = [];\n                \n                for (let i = 0; i < this.rows; i++) {\n                    this.grid[i] = [];\n                    this.nextGrid[i] = [];\n                    for (let j = 0; j < this.cols; j++) {\n                        this.grid[i][j] = 0.1;\n                        this.nextGrid[i][j] = 0.1;\n                    }\n                }\n            }\n\n            addHeat(x, y, amount) {\n                const col = Math.floor(x / this.res);\n                const row = Math.floor(y / this.res);\n                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {\n                    this.grid[row][col] = Math.min(1, this.grid[row][col] + amount);\n                }\n            }\n\n            getTemperature(x, y) {\n                const col = Math.floor(x / this.res);\n                const row = Math.floor(y / this.res);\n                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {\n                    return this.grid[row][col];\n                }\n                return 0.1;\n            }\n\n            update() {\n                // Heat diffusion using convolution\n                for (let i = 0; i < this.rows; i++) {\n                    for (let j = 0; j < this.cols; j++) {\n                        let sum = 0;\n                        let count = 0;\n                        \n                        for (let di = -1; di <= 1; di++) {\n                            for (let dj = -1; dj <= 1; dj++) {\n                                const ni = (i + di + this.rows) % this.rows;\n                                const nj = (j + dj + this.cols) % this.cols;\n                                sum += this.grid[ni][nj];\n                                count++;\n                            }\n                        }\n                        \n                        // Diffusion + cooling\n                        this.nextGrid[i][j] = (sum / count) * 0.98;\n                    }\n                }\n                \n                [this.grid, this.nextGrid] = [this.nextGrid, this.grid];\n            }\n\n            draw() {\n                for (let i = 0; i < this.rows; i++) {\n                    for (let j = 0; j < this.cols; j++) {\n                        const temp = this.grid[i][j];\n                        const alpha = temp * 0.3;\n                        \n                        if (alpha > 0.01) {\n                            // Color based on temperature\n                            const hue = 180 - temp * 60; // cyan to green\n                            ctx.fillStyle = `hsla(${hue}, 50%, 50%, ${alpha})`;\n                            ctx.fillRect(j * this.res, i * this.res, this.res, this.res);\n                        }\n                    }\n                }\n            }\n        }\n\n        // System state\n        let particles = [];\n        let field = new TemperatureField(30);\n        let running = true;\n        let mouseDown = false;\n        let mouseX = 0;\n        let mouseY = 0;\n\n        // Interaction\n        canvas.addEventListener('mousedown', (e) => {\n            mouseDown = true;\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            \n            // Plant seed\n            for (let i = 0; i < 5; i++) {\n                const angle = Math.random() * Math.PI * 2;\n                const dist = Math.random() * 30;\n                particles.push(new Particle(\n                    mouseX + Math.cos(angle) * dist,\n                    mouseY + Math.sin(angle) * dist,\n                    0.5 + Math.random() * 0.5\n                ));\n            }\n        });\n\n        canvas.addEventListener('mouseup', () => {\n            mouseDown = false;\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            \n            if (mouseDown) {\n                field.addHeat(mouseX, mouseY, 0.3);\n            }\n        });\n\n        document.addEventListener('keydown', (e) => {\n            if (e.code === 'Space') {\n                running = !running;\n                e.preventDefault();\n            }\n        });\n\n        document.getElementById('btn-clear').addEventListener('click', () => {\n            particles = [];\n            field = new TemperatureField(30);\n        });\n\n        document.getElementById('btn-cool').addEventListener('click', () => {\n            for (let i = 0; i < field.rows; i++) {\n                for (let j = 0; j < field.cols; j++) {\n                    field.grid[i][j] *= 0.5;\n                }\n            }\n        });\n\n        document.getElementById('btn-heat').addEventListener('click', () => {\n            for (let i = 0; i < 20; i++) {\n                field.addHeat(\n                    Math.random() * width,\n                    Math.random() * height,\n                    0.5\n                );\n            }\n        });\n\n        // Calculate system metrics\n        function calculateEntropy() {\n            if (particles.length === 0) return 0;\n            \n            // Velocity distribution entropy\n            let totalKE = 0;\n            for (let p of particles) {\n                const v = Math.sqrt(p.vx * p.vx + p.vy * p.vy);\n                totalKE += v * v;\n            }\n            return totalKE / particles.length;\n        }\n\n        function calculateOrder() {\n            if (particles.length === 0) return 0;\n            \n            // Measure structural order through bond count\n            let totalBonds = 0;\n            for (let p of particles) {\n                totalBonds += p.connections.length;\n            }\n            return (totalBonds / particles.length) / 10; // Normalize\n        }\n\n        // Main loop\n        function animate() {\n            // Clear with trail effect\n            ctx.fillStyle = 'rgba(13, 17, 23, 0.15)';\n            ctx.fillRect(0, 0, width, height);\n\n            if (running) {\n                // Update field\n                field.update();\n                \n                // Update particles\n                for (let p of particles) {\n                    p.update(field, particles);\n                }\n\n                // Spontaneous particle creation in high-temp regions\n                if (Math.random() < 0.02 && particles.length < 500) {\n                    const x = Math.random() * width;\n                    const y = Math.random() * height;\n                    const temp = field.getTemperature(x, y);\n                    \n                    if (temp > 0.4) {\n                        particles.push(new Particle(x, y, temp));\n                    }\n                }\n\n                "}