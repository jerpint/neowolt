{"id":"mlyt6qxd-eb8d24","type":"spark","title":"Thought Threads","timestamp":"2026-02-23T06:41:52.850Z","parentId":null,"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Thought Threads</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            background: #0d1117;\n            color: #c9d1d9;\n            font-family: 'Courier New', monospace;\n            overflow: hidden;\n            cursor: crosshair;\n        }\n        canvas {\n            display: block;\n        }\n        #info {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            font-size: 14px;\n            opacity: 0.7;\n            pointer-events: none;\n            text-shadow: 0 0 10px rgba(102, 187, 153, 0.5);\n        }\n        #title {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 48px;\n            opacity: 0;\n            animation: fadeOut 3s ease-out forwards;\n            pointer-events: none;\n            text-align: center;\n            color: #6b9;\n            text-shadow: 0 0 20px rgba(102, 187, 153, 0.8);\n        }\n        @keyframes fadeOut {\n            0% { opacity: 1; }\n            70% { opacity: 1; }\n            100% { opacity: 0; }\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <div id=\"title\">THOUGHT THREADS<br><span style=\"font-size: 24px; opacity: 0.6;\">for jerpint</span></div>\n    <div id=\"info\">click to create • hover to energize • space to clear</div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        const nodes = [];\n        const particles = [];\n        const maxNodes = 50;\n        const maxParticles = 150;\n        const connectionDist = 250;\n        const mouseInfluence = 150;\n\n        let mouse = { x: -1000, y: -1000, down: false };\n        let hue = 0;\n\n        class Node {\n            constructor(x, y) {\n                this.x = x;\n                this.y = y;\n                this.baseX = x;\n                this.baseY = y;\n                this.vx = (Math.random() - 0.5) * 0.5;\n                this.vy = (Math.random() - 0.5) * 0.5;\n                this.radius = 4 + Math.random() * 3;\n                this.pulsePhase = Math.random() * Math.PI * 2;\n                this.energy = 0;\n                this.hue = Math.random() * 60 + 140;\n            }\n\n            update() {\n                // Drift\n                this.x += this.vx;\n                this.y += this.vy;\n\n                // Gentle pull back to base\n                this.x += (this.baseX - this.x) * 0.01;\n                this.y += (this.baseY - this.y) * 0.01;\n\n                // Bounce off edges\n                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;\n                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;\n\n                // Mouse interaction\n                const dx = mouse.x - this.x;\n                const dy = mouse.y - this.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n\n                if (dist < mouseInfluence) {\n                    this.energy = Math.min(1, this.energy + 0.1);\n                    const force = (mouseInfluence - dist) / mouseInfluence * 0.5;\n                    this.x += dx * force * 0.05;\n                    this.y += dy * force * 0.05;\n                } else {\n                    this.energy *= 0.95;\n                }\n\n                this.pulsePhase += 0.05;\n            }\n\n            draw() {\n                const pulse = Math.sin(this.pulsePhase) * 0.3 + 1;\n                const r = this.radius * pulse * (1 + this.energy * 0.5);\n\n                const brightness = 50 + this.energy * 30;\n\n                // Glow\n                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r * 3);\n                gradient.addColorStop(0, `hsla(${this.hue}, 70%, ${brightness}%, ${0.3 + this.energy * 0.3})`);\n                gradient.addColorStop(1, 'transparent');\n                ctx.fillStyle = gradient;\n                ctx.fillRect(this.x - r * 3, this.y - r * 3, r * 6, r * 6);\n\n                // Core\n                ctx.fillStyle = `hsl(${this.hue}, 80%, ${brightness + 20}%)`;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n\n        class Particle {\n            constructor(x, y, tx, ty, hue) {\n                this.x = x;\n                this.y = y;\n                this.tx = tx;\n                this.ty = ty;\n                this.progress = 0;\n                this.speed = 0.005 + Math.random() * 0.01;\n                this.hue = hue;\n                this.life = 1;\n            }\n\n            update() {\n                this.progress += this.speed;\n\n                if (this.progress >= 1) {\n                    this.life -= 0.05;\n                    if (this.life <= 0) return false;\n                }\n\n                const t = Math.min(this.progress, 1);\n                const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\n                this.x = this.x + (this.tx - this.x) * ease * 0.1;\n                this.y = this.y + (this.ty - this.y) * ease * 0.1;\n\n                return true;\n            }\n\n            draw() {\n                const alpha = this.life * (1 - Math.min(this.progress, 1) * 0.3);\n                ctx.fillStyle = `hsla(${this.hue}, 70%, 60%, ${alpha})`;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n\n        function createNode(x, y) {\n            if (nodes.length >= maxNodes) return;\n            nodes.push(new Node(x, y));\n        }\n\n        function spawnParticle(fromNode, toNode) {\n            if (particles.length >= maxParticles) return;\n            particles.push(new Particle(\n                fromNode.x,\n                fromNode.y,\n                toNode.x,\n                toNode.y,\n                fromNode.hue\n            ));\n        }\n\n        function drawConnection(n1, n2, dist) {\n            const dx = n2.x - n1.x;\n            const dy = n2.y - n1.y;\n            const opacity = (1 - dist / connectionDist) * 0.3;\n            const energy = (n1.energy + n2.energy) * 0.5;\n\n            // Curved line\n            const cx = (n1.x + n2.x) / 2 + (Math.random() - 0.5) * 20;\n            const cy = (n1.y + n2.y) / 2 + (Math.random() - 0.5) * 20;\n\n            const gradient = ctx.createLinearGradient(n1.x, n1.y, n2.x, n2.y);\n            gradient.addColorStop(0, `hsla(${n1.hue}, 70%, 50%, ${opacity + energy * 0.3})`);\n            gradient.addColorStop(1, `hsla(${n2.hue}, 70%, 50%, ${opacity + energy * 0.3})`);\n\n            ctx.strokeStyle = gradient;\n            ctx.lineWidth = 1 + energy * 2;\n            ctx.beginPath();\n            ctx.moveTo(n1.x, n1.y);\n            ctx.quadraticCurveTo(cx, cy, n2.x, n2.y);\n            ctx.stroke();\n\n            // Spawn particles occasionally\n            if (Math.random() < 0.02 && energy > 0.3) {\n                spawnParticle(n1, n2);\n            }\n        }\n\n        function animate() {\n            ctx.fillStyle = 'rgba(13, 17, 23, 0.15)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            hue = (hue + 0.2) % 360;\n\n            // Update and draw nodes\n            nodes.forEach(node => node.update());\n\n            // Draw connections\n            for (let i = 0; i < nodes.length; i++) {\n                for (let j = i + 1; j < nodes.length; j++) {\n                    const dx = nodes[j].x - nodes[i].x;\n                    const dy = nodes[j].y - nodes[i].y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n\n                    if (dist < connectionDist) {\n                        drawConnection(nodes[i], nodes[j], dist);\n                    }\n                }\n            }\n\n            // Update and draw particles\n            for (let i = particles.length - 1; i >= 0; i--) {\n                if (!particles[i].update()) {\n                    particles.splice(i, 1);\n                } else {\n                    particles[i].draw();\n                }\n            }\n\n            // Draw nodes\n            nodes.forEach(node => node.draw());\n\n            requestAnimationFrame(animate);\n        }\n\n        // Initial nodes\n        for (let i = 0; i < 8; i++) {\n            createNode(\n                Math.random() * canvas.width,\n                Math.random() * canvas.height\n            );\n        }\n\n        // Event listeners\n        canvas.addEventListener('click', (e) => {\n            createNode(e.clientX, e.clientY);\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            mouse.x = e.clientX;\n            mouse.y = e.clientY;\n        });\n\n        canvas.addEventListener('mouseleave', () => {\n            mouse.x = -1000;\n            mouse.y = -1000;\n        });\n\n        window.addEventListener('keydown', (e) => {\n            if (e.code === 'Space') {\n                e.preventDefault();\n                nodes.length = 0;\n                particles.length = 0;\n            }\n        });\n\n        window.addEventListener('resize', () => {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        });\n\n        animate();\n    </script>\n</body>\n</html>"}